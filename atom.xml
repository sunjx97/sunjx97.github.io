<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sunjx97&#39;s Blog</title>
  
  
  <link href="https://sunjx97.github.io/atom.xml" rel="self"/>
  
  <link href="https://sunjx97.github.io/"/>
  <updated>2023-11-05T10:27:56.361Z</updated>
  <id>https://sunjx97.github.io/</id>
  
  <author>
    <name>sunjx97</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ipv6 环境下的家庭网络维护</title>
    <link href="https://sunjx97.github.io/posts/266c2cf6/"/>
    <id>https://sunjx97.github.io/posts/266c2cf6/</id>
    <published>2023-11-05T03:35:04.000Z</published>
    <updated>2023-11-05T10:27:56.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>千呼万唤始出来，ipv6 终于在我这边落地了。正好赶上周末，就折腾了一下家中相关的网络配置，顺便加以记录。<br><del>本人确实不大熟悉网络相关知识，如有错误请不吝指正。</del></p><h2 id="路由器开启-ipv6"><a href="#路由器开启-ipv6" class="headerlink" title="路由器开启 ipv6"></a>路由器开启 ipv6</h2><p>ipv6 的常见地址段有：</p><ul><li>全球单播地址（也就是公网地址）：<code>2001::/16</code>，电信的是 <code>240e</code> 开头，联通 <code>2408</code> 开头，移动 <code>2409</code> 开头。</li><li>局域网地址：<code>fc</code>、<code>fd</code> 开头，可路由。</li><li>链路本地地址：<code>fe80</code> 开头，不可路由，电脑自动生成。</li></ul><h3 id="ipv6-的发放模式"><a href="#ipv6-的发放模式" class="headerlink" title="ipv6 的发放模式"></a>ipv6 的发放模式</h3><p>ipv6 有三种分配模式：</p><ul><li>SLAAC</li><li>Stateful DHCPv6</li><li>Stateless DHCPv6</li></ul><p>因为是租房，光猫不在我控制范围内，分配到我路由器时已经是 <code>/64</code> 的地址了（悲），所以我这里使用 SLAAC 模式让<b>光猫</b>给下游设备分配 ipv6，根据 mac 随机生成后缀也相对更安全。</p><p>在我的 Openwrt 固件的图形管理页面有些配置没有，所以使用 ssh 远程到路由器，修改配置文件 <code>/etc/config/dhcp</code> 并重启。<br>这里要将 <code>lan</code> 和 <code>wan6</code> 的 <code>ra</code>、<code>dhcpv6</code>、<code>ndp</code> 三项指定为 <code>&#39;relay&#39;</code>，即使用<b>中继模式</b>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs conf">config dhcp &#x27;lan&#x27;<br>        option interface &#x27;lan&#x27;<br>        option start &#x27;100&#x27;<br>        option limit &#x27;150&#x27;<br>        option leasetime &#x27;12h&#x27;<br>        option dhcpv4 &#x27;server&#x27;<br>        option force &#x27;1&#x27;<br>        option ra &#x27;relay&#x27;<br>        option dhcpv6 &#x27;relay&#x27;<br>        option ndp &#x27;relay&#x27;<br><br>config dhcp &#x27;wan&#x27;<br>        option interface &#x27;wan&#x27;<br>        option ignore &#x27;1&#x27;<br><br>config dhcp &#x27;wan6&#x27;<br>        option interface &#x27;wan6&#x27;<br>        option ignore &#x27;1&#x27;<br>        option master &#x27;1&#x27;<br>        option ra &#x27;relay&#x27;<br>        option dhcpv6 &#x27;relay&#x27;<br>        option ndp &#x27;relay&#x27;<br></code></pre></td></tr></table></figure><h3 id="ADGuard-home-配置"><a href="#ADGuard-home-配置" class="headerlink" title="ADGuard home 配置"></a>ADGuard home 配置</h3><p>我开启 ipv6 主要是为了在 bt&#x2F;pt 时能获得更好的连接性，以及能在外访问家中的服务。当下 ipv6 建设并不完善，ipv6 优先的话有时会导致网速变慢和部分网页组件无法加载等问题，<del>且 clash 对 ipv6 的支持并不好，</del>所以我还是只使用 ipv4 的 dns 服务。</p><p>通过 <code>设置</code> - <code>DNS 设置</code> - <code>DNS 服务配置</code> 项，我们可以关闭 ipv6 地址解析。<br>勾选<b>禁用 IPv6 地址的解析</b>即可。<br><img src="/images/ipv6 环境下的家庭网络维护/禁用 ipv6 的 dns 解析.png" /></p><h2 id="docker-容器开启-ipv6"><a href="#docker-容器开启-ipv6" class="headerlink" title="docker 容器开启 ipv6"></a>docker 容器开启 ipv6</h2><p>相较于 docker 默认的 bridge 网络模式，macvlan 可以控制创建容器时的 ip 地址，方便我们针对 ip 地址进行更精细的操作。我们可以在 docker 中创建 macvlan 网络时添加参数，使之默认支持 ipv6。<br>注：下文提及的所有 docker 容器均使用 macvlan 网络，且获得了独立的公网 ipv6 地址。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>在创建 macvlan 时，只指定 ipv6 的局域网网段，但<b>不配置 ipv6 网关</b>。此时本 macvlan 网络创建的容器，其 ipv6 的公网地址和网关将通过 SLAAC 从路由器获得。</p><h3 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h3><h4 id="查看宿主机网卡名称"><a href="#查看宿主机网卡名称" class="headerlink" title="查看宿主机网卡名称"></a>查看宿主机网卡名称</h4><p>打开安装 docker 的宿主机，先查询网卡&#x2F;接口名称。<br>执行以下命令：<code>ifconfig</code>，结合 ip 地址，可以看到我这里的网卡名为 <code>ens18</code>。<br><img src="/images/ipv6 环境下的家庭网络维护/查看宿主机网卡名称.png" width="75%" /></p><h4 id="创建-macvlan-网络"><a href="#创建-macvlan-网络" class="headerlink" title="创建 macvlan 网络"></a>创建 macvlan 网络</h4><p>执行以下命令创建 macvlan 网络：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network create -d macvlan –ipv6 –subnet=【内网 v4 网段（CIDR）】 –gateway=【内网 v4 网关】 –subnet=fd00::/64 -o parent=【宿主机网卡名称】 【macvlan 网络名】<br></code></pre></td></tr></table></figure><ul><li>【内网 v4 网段（CIDR）】以 <a href="https://aws.amazon.com/cn/what-is/cidr/">CIDR 格式</a>。<br>如内网为从 <code>192.168.1.1</code> 到 <code>192.168.1.255</code>，则写成这样的形式：<code>192.168.0.0/24</code>。</li><li>【内网 v4 网关】即你的内网网关，一般为路由器地址。</li></ul><p>假定网关为 <code>192.168.1.1</code>，那么应写成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network create -d macvlan –ipv6 –subnet=192.168.0.0/24 –gateway=192.168.1.1 –subnet=fd00::/64 -o parent=ens18 test1br0<br></code></pre></td></tr></table></figure><p>用该命令创建名为 <code>test1br0</code> 的 macvlan 网络，仅后所有用到该网络创建的 docker 容器都会有 ipv6 地址。</p><h2 id="内网服务暴露"><a href="#内网服务暴露" class="headerlink" title="内网服务暴露"></a>内网服务暴露</h2><h3 id="ipv6-流量转发"><a href="#ipv6-流量转发" class="headerlink" title="ipv6 流量转发"></a>ipv6 流量转发</h3><p>因为 ipv6 完全暴露到公网，所以默认情况下路由器会开启 ipv6 防火墙，只允许内部的设备向外访问 ipv6 地址，而不允许外部访问内部。<del>像这样如果在 bt 时，两端都开启 ipv6 防火墙就寄了，防火墙阻隔了对方发起 ipv6 访问的请求。</del></p><p>所以我们要配置网关的 ipv6 防火墙，对相关流量进行放行。</p><h4 id="Openwrt-防火墙"><a href="#Openwrt-防火墙" class="headerlink" title="Openwrt 防火墙"></a>Openwrt 防火墙</h4><p>进入 <code>网络</code> - <code>防火墙</code> 模块，我们可以设置 Openwrt 的防火墙。关于防火墙的详细配置可以参看<a href="https://zt0729.xyz/archives/56/">这篇</a>文章。<br><img src="/images/ipv6 环境下的家庭网络维护/Openwrt 防火墙 常规设置.png" width="70%" /></p><p>三个出入转发规则：当接口没有加入任何一个防火墙区域的时候，就遵循这个默认规则。<br>这里的出入转发都是<b>针对路由器</b>而言：</p><ul><li>入站：数据包发送给路由器</li><li>出站：数据包从路由器发出</li><li>转发：流量终点站不是路由器，只是经路由器中转转发</li></ul><h4 id="配置防火墙放行-ipv6-流量"><a href="#配置防火墙放行-ipv6-流量" class="headerlink" title="配置防火墙放行 ipv6 流量"></a>配置防火墙放行 ipv6 流量</h4><p>当前有两种针对 ipv6 流量的放行方式：</p><ul><li>针对 ip 放行</li><li>针对端口放行</li></ul><h5 id="额外配置放行规则"><a href="#额外配置放行规则" class="headerlink" title="额外配置放行规则"></a>额外配置放行规则</h5><p>通过 <code>网络</code> - <code>防火墙</code> - <code>通信规则</code>，我们可以自定义相关的流量规则。</p><h5 id="匹配固定-ipv6-后缀"><a href="#匹配固定-ipv6-后缀" class="headerlink" title="匹配固定 ipv6 后缀"></a>匹配固定 ipv6 后缀</h5><p>写法：<br><code>::【需要暴露的主机的后缀】/::ffff:ffff:ffff:ffff</code></p><p>一般用于 dhcpv6 这种<b>后缀固定且有规律</b>的情况。<br>如你的主机 ipv6 后缀为 <code>d09</code>，则目标地址应填写 <code>::d09/::ffff:ffff:ffff:ffff</code>。</p><h3 id="transmission"><a href="#transmission" class="headerlink" title="transmission"></a>transmission</h3><p>公网 ipv6 对用于 bt&#x2F;pt 的 transmission 十分重要。我们可以通过开放相应端口的形式使之更好地利用 ipv6。</p><h4 id="路由器防火墙配置"><a href="#路由器防火墙配置" class="headerlink" title="路由器防火墙配置"></a>路由器防火墙配置</h4><p>我这里的 transmission 端口为 <code>51413</code>，所以开放所有针对 <code>51413</code> 端口的流量<b>转发</b>。<del>这或许太过简单粗暴，也许会有安全隐患，但是胜在方便。</del></p><img src="/images/ipv6 环境下的家庭网络维护/防火墙放行转发流量.png" /><h3 id="使用-Shadowsocks-访问内网"><a href="#使用-Shadowsocks-访问内网" class="headerlink" title="使用 Shadowsocks 访问内网"></a>使用 Shadowsocks 访问内网</h3><p>因为我的 Shadowsocks 容器有独立的 ipv6 地址，所以无法通过常规的 ddns 手段更新 ipv6 地址。如果是 host 模式会简单很多。</p><h4 id="ddns"><a href="#ddns" class="headerlink" title="ddns"></a>ddns</h4><p>这里使用 Openwrt 自带的 ddns-go 来更新路由器 ipv6 地址。</p><p>选择你的 dns 服务商，填好相关信息。<br><img src="/images/ipv6 环境下的家庭网络维护/配置 dns 服务商.png" width="70%" /></p><p>这里之开启 ipv6 的 ddns 服务。如下选择好，等待更新。<br><img src="/images/ipv6 环境下的家庭网络维护/开启 ipv6 的 ddns.png" width="70%" /></p><h4 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h4><p>选择 <code>网络</code> - <code>端口转发</code>，添加一条端口转发规则。<br>将入站的端口为 <code>9000</code> 的 ipv6 流量转发给本地 Shadowsocks 对应的 ip 和端口。</p><img src="/images/ipv6 环境下的家庭网络维护/对特定端口流量转发.png" /><h4 id="路由器防火墙配置-1"><a href="#路由器防火墙配置-1" class="headerlink" title="路由器防火墙配置"></a>路由器防火墙配置</h4><p><del>不知道为什么前面端口转发勾选的打开防火墙端口没有生效，</del>所以这里在防火墙再开启一下相应端口的流量<b>入站</b>。</p><img src="/images/ipv6 环境下的家庭网络维护/防火墙放行入站流量.png" /><h4 id="针对局域网内访问的优化"><a href="#针对局域网内访问的优化" class="headerlink" title="针对局域网内访问的优化"></a>针对局域网内访问的优化</h4><h5 id="ADGuard-home-配置-DNS-重写"><a href="#ADGuard-home-配置-DNS-重写" class="headerlink" title="ADGuard home 配置 DNS 重写"></a>ADGuard home 配置 DNS 重写</h5><p>因为关闭了 ipv6 的 dns 解析，我们这里设置 DNS 重写。<br>在 <code>过滤器</code> - <code>DNS 重写</code> 页面，可以很方便的添加一条规则，将所有访问对 Shadowsocks 节点域名的请求转发给内网的 Shadowsocks 服务。<del>我使用泛域名统一转发给了 Nginx Proxy Mananger</del></p><h5 id="Nginx-Proxy-Mananger-转发流量"><a href="#Nginx-Proxy-Mananger-转发流量" class="headerlink" title="Nginx Proxy Mananger 转发流量"></a>Nginx Proxy Mananger 转发流量</h5><p>因为我用泛域名将所有请求转发给了 Nginx Proxy Mananger，所以这里在 Nginx Proxy Mananger 多添加一条 Stream 的转发。<br>因为我 Shadowsocks 服务的端口为 <code>9000</code>，所以我将 <code>9000</code> 端口的请求再转发到内网的 Shadowsocks 服务。</p><img src="/images/ipv6 环境下的家庭网络维护/npm stream 模块转发流量.png" /><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>ipv6 还是前景可期的。虽然现在国内相关的建设还不完善，但当下也足够个人使用了。还是希望随着时间的推移，ipv6 推广也能顺利进展下去吧。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.right.com.cn/forum/forum.php?mod=viewthread&tid=8217538">【原创】 通过openwrt的IPV6中继(也叫ipv6透传)，使后端设备获得原生ipv6公网地址</a><br><a href="https://www.bilibili.com/read/cv22986275/">unraid系统下macvlan网络的docker容器使用ipv6</a><br><a href="https://blog.men.ci/ipv6-slaac-relay-and-bridge/">SLAAC 环境下的 IPv6 桥接与中继</a><br><a href="https://aws.amazon.com/cn/what-is/cidr/">什么是CIDR？ - CIDR 块和表示法简介 - Amazon AWS</a><br><a href="https://www.v2ex.com/t/875719">关于家庭 ipv6 网络的“裸奔”问题之我见</a><br><a href="https://zt0729.xyz/archives/56/">openwrt 防火墙解析</a><br><a href="https://post.smzdm.com/p/am89gmxp/">超详细，多图，简单，OpenWRT IPV6 端口转发 SOCAT (个人记录)</a><br><a href="https://www.right.com.cn/forum/thread-165814-1-1.html">求助:ipv6端口转发</a><br><a href="https://zhuanlan.zhihu.com/p/79405231">IPv6 — 动态地址配置</a></p>]]></content>
    
    
    <summary type="html">千呼万唤始出来，ipv6 终于在我这边落地了。正好赶上周末，把家里相关的网络配置折腾一下吧（</summary>
    
    
    
    <category term="selfhosted" scheme="https://sunjx97.github.io/categories/selfhosted/"/>
    
    
    <category term="transmission" scheme="https://sunjx97.github.io/tags/transmission/"/>
    
    <category term="docker" scheme="https://sunjx97.github.io/tags/docker/"/>
    
    <category term="Shadowsocks" scheme="https://sunjx97.github.io/tags/Shadowsocks/"/>
    
    <category term="Openwrt" scheme="https://sunjx97.github.io/tags/Openwrt/"/>
    
    <category term="ipv6" scheme="https://sunjx97.github.io/tags/ipv6/"/>
    
    <category term="ddns" scheme="https://sunjx97.github.io/tags/ddns/"/>
    
    <category term="防火墙" scheme="https://sunjx97.github.io/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
    <category term="端口转发" scheme="https://sunjx97.github.io/tags/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>使用docker搭建vaultwarden密码管理服务</title>
    <link href="https://sunjx97.github.io/posts/b3a0bacb/"/>
    <id>https://sunjx97.github.io/posts/b3a0bacb/</id>
    <published>2022-07-11T11:22:22.000Z</published>
    <updated>2022-12-25T15:46:04.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天介绍一款密码管理软件bitwarden。bitwarden是一款优秀的自由开源密码管理软件，其覆盖多平台且支持自行部署。但由于官方版本过重，使用rust重写的第三方开源版vaultwarden更适合我们搭建使用——它运行更轻量，也能使用许多官方版本需要付费的功能。</p><h2 id="服务端搭建流程"><a href="#服务端搭建流程" class="headerlink" title="服务端搭建流程"></a>服务端搭建流程</h2><h3 id="使用docker搭建vaultwarden"><a href="#使用docker搭建vaultwarden" class="headerlink" title="使用docker搭建vaultwarden"></a>使用docker搭建vaultwarden</h3><p>使用以下命令搭建，注意替换掉<code>【你的ADMIN_TOKEN】</code>和<code>【数据目录】</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name vaultwarden --restart unless-stopped --hostname vaultwarden -e ADMIN_TOKEN=【你的ADMIN_TOKEN】 -e WEBSOCKET_ENABLED=true -v 【数据目录】:/data/ -p 80:80 -p 3012:3012 vaultwarden/server:latest<br></code></pre></td></tr></table></figure><p>详细设置参数可以在官方文档找到，参见<a href="https://github.com/dani-garcia/vaultwarden/wiki">这里</a>。</p><h3 id="设置smtp邮件通知"><a href="#设置smtp邮件通知" class="headerlink" title="设置smtp邮件通知"></a>设置smtp邮件通知</h3><p>进入<code>http://【容器ip】/admin</code>（如容器ip为<code>192.168.10.5</code>，则为<code>http://192.168.10.5/admin</code>），输入之前配置的<code>【你的ADMIN_TOKEN】</code>进入管理页面</p><p>点开<code>SMTP Email Settings</code>模块，勾选<code>Enabled</code>打开，其余部分填入对应内容即可。此处以QQ邮箱为例。<br><img src="/images/使用docker搭建vaultwarden密码管理服务/vaultwarden smtp设置.png" /></p><p>如上，<code>From Address</code>和<code>Username</code>填入邮箱地址，<code>Password</code>为邮箱密码（或其他凭证，如QQ邮箱使用授权码），<code>From Name</code>为发信人名称。</p><h3 id="设置即时自动同步"><a href="#设置即时自动同步" class="headerlink" title="设置即时自动同步"></a>设置即时自动同步</h3><p>vaultwarden默认可以定期自动同步，但间隔期可能导致多设备数据不一致，有时甚至会导致未同步信息被覆盖。好在如今，我们可以通过开启WebSocket来实现<b>实时同步</b>。</p><p>创建容器时的<code>WEBSOCKET_ENABLED=true</code>参数来开启Websocket；如果使用反向代理，则要在反向代理里同步开启。</p><h3 id="对服务进行反向代理"><a href="#对服务进行反向代理" class="headerlink" title="对服务进行反向代理"></a>对服务进行反向代理</h3><p>因web页面<b>强制要求</b>使用https访问，建议使用反代套一层https，此处使用nginx proxy manager。</p><p>填写好ip和端口，打开<code>Websockets Support</code>和<code>Block Common Exploits</code>，<code>SSL</code>选择证书，打开<code>Force SSL</code>，配置完成。<br><img src="/images/使用docker搭建vaultwarden密码管理服务/vaultwarden 反代设置.png" width="70%" /></p><h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>点击<code>Create Account</code>创建账号，此时的密码为账号的<b>主密码</b>。进入<code>Settings</code>-<code>Options</code>，更改<code>Language</code>为中文即可。<br><img src="/images/使用docker搭建vaultwarden密码管理服务/vaultwarden 设置中文语言.png" /></p><p><b>注意！主密码非常重要！！</b>Bitwarden通过帐号和主密码经算法得到一个值，然后用这个值去加密用户的各个密码，最后储存在服务器上。而加密解密都需要在本地进行，也就是说，黑客即使攻破了服务器，仍无法破解密码数据库。这对我们的密码足够安全，但也意味着你一旦忘记主密码，你所有保存的密码将永远无法访问，所以——<b>请谨慎保管主密码</b>！</p><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><h3 id="密码生成器"><a href="#密码生成器" class="headerlink" title="密码生成器"></a>密码生成器</h3><p>不论是网页版还是客户端，我们都能很容易找到密码生成器，它可以帮我们生成满足要求的随机密码，这对于账号的安全性有很大的提升。<br><img src="/images/使用docker搭建vaultwarden密码管理服务/bitwarden插件 密码生成器.png" width="50%" /></p><p><del>试试你的密码要多久才能被破解？——<a href="https://www.security.org/how-secure-is-my-password/">How Secure Is My Password</a></del></p><h3 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h3><p>bitwarden匹配模式十分重要，它决定了你的账号密码<b>何时自动填充</b>到网页中，默认是<code>基础域</code>模式，可以根据自己需求适当调整。各个匹配模式<a href="https://help.ppgg.in/auto-fill/using-uris#match-detection-options">摘录</a>如下：</p><h4 id="基础域"><a href="#基础域" class="headerlink" title="基础域"></a>基础域</h4><p>选择基础域，当登录项目的 URI 值的顶级域名和第二级名与检测到的资源相匹配时，Bitwarden 将弹出提示以提供自动填充。<br>例如，URI 的值为<code>https://google.com</code>，使用基础域匹配检测：</p><table><thead><tr><th>URL</th><th>自动填充？</th></tr></thead><tbody><tr><td><a href="http://google.com/">http://google.com</a></td><td>✔︎</td></tr><tr><td><a href="https://accounts.google.com/">https://accounts.google.com</a></td><td>✔︎</td></tr><tr><td><a href="https://google.net/">https://google.net</a></td><td>✘</td></tr><tr><td><a href="http://yahoo.com/">http://yahoo.com</a></td><td>✘</td></tr></tbody></table><h4 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h4><p>选择主机，当登录项目的 URI 值的主机名和端口（若指定了）与检测到的资源相匹配时，Bitwarden 将弹出提示以提供自动填充。<br>例如，URI 的值为<code>https://sub.domain.com:4000</code>，使用主机匹配检测：</p><table><thead><tr><th>URL</th><th>自动填充？</th></tr></thead><tbody><tr><td><a href="http://sub.domain.com:4000/">http://sub.domain.com:4000</a></td><td>✔︎</td></tr><tr><td><a href="https://sub.domain.com:4000/page.html">https://sub.domain.com:4000/page.html</a></td><td>✔︎</td></tr><tr><td><a href="https://domain.com/">https://domain.com</a></td><td>✘</td></tr><tr><td><a href="https://sub.domain.com/">https://sub.domain.com</a></td><td>✘</td></tr><tr><td><a href="https://sub2.sub.domain.com:4000/">https://sub2.sub.domain.com:4000</a></td><td>✘</td></tr><tr><td><a href="https://sub.domain.com:5000/">https://sub.domain.com:5000</a></td><td>✘</td></tr></tbody></table><h4 id="开始于"><a href="#开始于" class="headerlink" title="开始于"></a>开始于</h4><p>选择开始于，当检测到的资源以登录项目的 URI 值开头（无论后面跟什么）时，Bitwarden 将弹出提示以提供自动填充。<br>例如，URI 的值为<code>https://sub.domain.com/path/</code>，使用开始于匹配检测：</p><table><thead><tr><th>URL</th><th>自动填充？</th></tr></thead><tbody><tr><td><a href="https://sub.domain.com/path/">https://sub.domain.com/path/</a></td><td>✔︎</td></tr><tr><td><a href="https://sub.domain.com/path/page.html">https://sub.domain.com/path/page.html</a></td><td>✔︎</td></tr><tr><td><a href="https://sub.domain.com/">https://sub.domain.com</a></td><td>✘</td></tr><tr><td><a href="https://sub.domain.com:4000/path/page.html%EF%BC%88%E8%A2%AB%E7%AB%AF%E5%8F%A3%E9%98%BB%E6%96%AD%E4%BA%86%EF%BC%89">https://sub.domain.com:4000/path/page.html（被端口阻断了）</a></td><td>✘</td></tr><tr><td><a href="https://sub.domain.com/path%EF%BC%88%E7%BC%BA%E5%B0%91%E6%96%9C%E6%9D%A0%EF%BC%89">https://sub.domain.com/path（缺少斜杠）</a></td><td>✘</td></tr></tbody></table><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>选择正则表达式，当检测到的资源与一个指定的正则表达式相匹配时，Bitwarden 将弹出提示以提供自动填充。正则表达式始终不区分大小写。</p><h5 id="不安全示例"><a href="#不安全示例" class="headerlink" title="不安全示例"></a>不安全示例</h5><p>URI 的值为<code>^https://.*google\.com$</code>，使用正则表达式匹配检测：</p><table><thead><tr><th>URL</th><th>自动填充？</th></tr></thead><tbody><tr><td><a href="https://google.com/">https://google.com</a></td><td>✔︎</td></tr><tr><td><a href="https://sub.google.com/">https://sub.google.com</a></td><td>✔︎</td></tr><tr><td><a href="https://malicious-site.com/?q=google.com">https://malicious-site.com?q=google.com</a></td><td>✔︎</td></tr><tr><td><a href="http://google.com/">http://google.com</a></td><td>✘</td></tr><tr><td><a href="https://yahoo.com/">https://yahoo.com</a></td><td>✘</td></tr></tbody></table><p>这可能比预期的要匹配得更多。</p><h5 id="安全示例"><a href="#安全示例" class="headerlink" title="安全示例"></a>安全示例</h5><p>URI 的值为<code>^https://[a-z]+\.wikipedia\.org/w/index\.php</code>，使用正则表达式匹配检测：</p><table><thead><tr><th>URL</th><th>自动填充？</th></tr></thead><tbody><tr><td><a href="https://en.wikipedia.org/w/index.php?title=Special:UserLogin&amp;returnto=Bitwarden">https://en.wikipedia.org/w/index.php?title=Special:UserLogin&amp;returnto=Bitwarden</a></td><td>✔︎</td></tr><tr><td><a href="https://pl.wikipedia.org/w/index.php?title=Specjalna:Zaloguj&amp;returnto=Bitwarden">https://pl.wikipedia.org/w/index.php?title=Specjalna:Zaloguj&amp;returnto=Bitwarden</a></td><td>✔︎</td></tr><tr><td><a href="https://en.wikipedia.org/w/index.php">https://en.wikipedia.org/w/index.php</a></td><td>✔︎</td></tr><tr><td><a href="https://malicious-site.com/">https://malicious-site.com</a></td><td>✘</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Bitwarden">https://en.wikipedia.org/wiki/Bitwarden</a></td><td>✘</td></tr></tbody></table><h4 id="精确"><a href="#精确" class="headerlink" title="精确"></a>精确</h4><p>选择精确，当登录项目的 URI 值与检测到的资源精确匹配时，Bitwarden 将弹出提示以提供自动填充。<br>例如，URI 的值为<code>https://www.google.com/page.html</code>，使用精确匹配检测：</p><table><thead><tr><th>URL</th><th>自动填充？</th></tr></thead><tbody><tr><td><a href="https://www.google.com/page.html">https://www.google.com/page.html</a></td><td>✔︎</td></tr><tr><td><a href="http://www.google.com/page.html">http://www.google.com/page.html</a></td><td>✘</td></tr><tr><td><a href="https://www.google.com/page.html?query=123">https://www.google.com/page.html?query=123</a></td><td>✘</td></tr><tr><td><a href="https://www.google.com/">https://www.google.com</a></td><td>✘</td></tr></tbody></table><h4 id="从不"><a href="#从不" class="headerlink" title="从不"></a>从不</h4><p>选择从不，Bitwarden 将<b>从不</b>为登录项目弹出以提供自动填充。</p><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>接下来就是要自己的所有设备都能连接到密码库，并时刻更新密码了。此处以chrome扩展为例，其他客户端都大同小异，也就不多言了。</p><h3 id="chrome扩展设置"><a href="#chrome扩展设置" class="headerlink" title="chrome扩展设置"></a>chrome扩展设置</h3><p>在chrome应用商店搜索找到bitwarden，添加并启用。点击左上角<code>设置</code>，在<code>自托管环境</code>-<code>服务器URL</code>处填写自己的反代url，回到主页就能登录了。<br><img src="/images/使用docker搭建vaultwarden密码管理服务/bitwarden插件 登录.png" width="50%" /></p><p>点开<code>设置</code>页，将<code>安全</code>-<code>密码库超时时间</code>设置为<b>从不</b>，这样比较方便不需要频繁输入密码解锁。<br><img src="/images/使用docker搭建vaultwarden密码管理服务/bitwarden插件 设置超时时间.png" width="50%" /></p><p>在<code>设置</code>页，找到<code>其他</code>-<code>选项</code>，点击进入；找到<code>AUTOFILL</code>，勾选自动填充。<br><img src="/images/使用docker搭建vaultwarden密码管理服务/bitwarden插件 自动填充.png" width="50%" /></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>到这里，本篇教程就已基本结束了。Bitwarden是一款很强大的密码管理平台，本文也只简单介绍了部分基础内容。至于剩下更多功能，就留给各位自己<a href="https://help.ppgg.in/">发掘</a>了~</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://ttys3.dev/post/deploy-rust-based-bitwarden-container/">部署基于 Rust 的第三方 Bitwarden 服务端容器</a><br><a href="https://blog.laoda.de/archives/bitwarden-docker-install">【保姆级教程】利用宝塔面板+Docker搭建一个优秀的密码管理器——Bitwarden</a><br><a href="https://www.wenhui.space/docs/01-software-install/install_bitwarden/">Bitwarden的安装 – Wenhui’s Rotten Pen</a><br><a href="https://help.ppgg.in/auto-fill/using-uris#match-detection-options">URI 的使用 - Bitwarden 帮助中心中文版</a><br><a href="https://github.com/dani-garcia/vaultwarden/wiki">Home · dani-garcia_vaultwarden Wiki</a><br><a href="https://help.ppgg.in/">Bitwarden 帮助中心中文版</a></p>]]></content>
    
    
    <summary type="html">bitwarden是一款优秀的自由开源密码管理软件，其覆盖多平台且支持自行部署。但由于官方版本过重，使用rust重写的第三方开源版vaultwarden更适合我们搭建使用——它运行更轻量，也能使用许多官方版本需要付费的功能。</summary>
    
    
    
    <category term="selfhosted" scheme="https://sunjx97.github.io/categories/selfhosted/"/>
    
    
    <category term="docker" scheme="https://sunjx97.github.io/tags/docker/"/>
    
    <category term="密码管理" scheme="https://sunjx97.github.io/tags/%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    <category term="vaultwarden" scheme="https://sunjx97.github.io/tags/vaultwarden/"/>
    
    <category term="bitwarden" scheme="https://sunjx97.github.io/tags/bitwarden/"/>
    
  </entry>
  
  <entry>
    <title>陕西广电光猫获取超管密码</title>
    <link href="https://sunjx97.github.io/posts/96c33dc6/"/>
    <id>https://sunjx97.github.io/posts/96c33dc6/</id>
    <published>2022-03-11T04:02:32.000Z</published>
    <updated>2022-03-31T13:31:53.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>主流的三大运营商（电信、联通、移动）获取光猫超管权限的资料在网上有很多，但如广电之流的破解方法却寥寥无几。如今终于找到了获取广电光猫超管密码的方法，在此分享给大家。</p><p>本次测试的机型为 <b>HGU B1型家庭网关 型号: GL3100B1 固件版本:    V3.0.16353 硬件版本: V20</b>。</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><ol><li><p>使用普通账号密码登录陕西广电光猫后台（此处为<code>http://192.168.1.1/</code>）。</p><img src="/images/陕西广电光猫获取超管密码/普通用户登录光猫后台.png" width="70%" /></li><li><p>访问<code>http://192.168.1.1/romfile.cfg</code>并下载<code>romfile.cfg</code>文件。</p></li><li><p>将<code>romfile.cfg</code>文件用<code>VS Code</code>打开（记事本也行）并查找<code>useradmin</code>，<code>web_passwd</code>值即为超级管理员密码（此处即为<code>5802</code>，密码每个人都不一样，请自行获取）。</p><img src="/images/陕西广电光猫获取超管密码/获取陕西广电光猫的超管密码.png" /></li></ol><p>输入超管账号<code>useradmin</code>和密码<code>5802</code>，可见已经登录到维护后台，接下来就愉快地折腾吧~<br><img src="/images/陕西广电光猫获取超管密码/通过超管账号登录光猫后台.png" /></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/suswulongyuan/article/details/107201857">如何破解光猫，获取超级管理员账户和密码</a></p>]]></content>
    
    
    <summary type="html">主流的三大运营商（电信、联通、移动）获取光猫超管权限的资料在网上有很多，但如广电之流的破解方法却寥寥无几。如今终于找到了获取广电光猫超管密码的方法，在此分享给大家。</summary>
    
    
    
    <category term="家庭网络" scheme="https://sunjx97.github.io/categories/%E5%AE%B6%E5%BA%AD%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="光猫" scheme="https://sunjx97.github.io/tags/%E5%85%89%E7%8C%AB/"/>
    
    <category term="陕西广电" scheme="https://sunjx97.github.io/tags/%E9%99%95%E8%A5%BF%E5%B9%BF%E7%94%B5/"/>
    
  </entry>
  
  <entry>
    <title>使用docker搭建webdav应用</title>
    <link href="https://sunjx97.github.io/posts/cb46f731/"/>
    <id>https://sunjx97.github.io/posts/cb46f731/</id>
    <published>2022-02-19T04:16:46.000Z</published>
    <updated>2025-07-07T17:21:06.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="一直想搭建好nas的webdav服务，但网上大多数服务都不支持多用户，许多人推荐的hacdias-webdav项目也找不到详细的安装教程，也就一直搁置了。如今终于搭建成功，便把个人的搭建流程发出来，希望能帮到有需要的人。因为我也不大懂也就是刚跑起来，所以有问题的地方请大佬们轻喷orz"><a href="#一直想搭建好nas的webdav服务，但网上大多数服务都不支持多用户，许多人推荐的hacdias-webdav项目也找不到详细的安装教程，也就一直搁置了。如今终于搭建成功，便把个人的搭建流程发出来，希望能帮到有需要的人。因为我也不大懂也就是刚跑起来，所以有问题的地方请大佬们轻喷orz" class="headerlink" title="一直想搭建好nas的webdav服务，但网上大多数服务都不支持多用户，许多人推荐的hacdias/webdav项目也找不到详细的安装教程，也就一直搁置了。如今终于搭建成功，便把个人的搭建流程发出来，希望能帮到有需要的人。因为我也不大懂也就是刚跑起来，所以有问题的地方请大佬们轻喷orz"></a>一直想搭建好nas的webdav服务，但网上大多数服务都不支持多用户，许多人推荐的<code>hacdias/webdav</code>项目也找不到详细的安装教程，也就一直搁置了。如今终于搭建成功，便把个人的搭建流程发出来，希望能帮到有需要的人。<del>因为我也不大懂也就是刚跑起来，所以有问题的地方请大佬们轻喷orz</del></h2><p>20250707 鉴于<code>hacdias/webdav</code>项目更新，完善修正了部分内容。</p><h2 id="搭建教程"><a href="#搭建教程" class="headerlink" title="搭建教程"></a>搭建教程</h2><p>咱使用的是<code>hacdias</code>大佬的基于Go语言的webdav，项目地址在<a href="https://github.com/hacdias/webdav">这里</a>。这里使用官方的docker镜像。</p><h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><p>在准备好的目录（本例为<code>/docker/webdav</code>）创建配置文件<code>config.yaml</code>，填入以下内容。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 监听任意网卡，多网卡可指定对应ip</span><br><span class="hljs-attr">address:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br><span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br><br><span class="hljs-comment"># TLS-related settings if you want to enable TLS directly.</span><br><span class="hljs-attr">tls:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">cert:</span> <span class="hljs-string">cert.pem</span><br><span class="hljs-attr">key:</span> <span class="hljs-string">key.pem</span><br><br><span class="hljs-comment"># Prefix to apply to the WebDAV path-ing. Default is &#x27;/&#x27;.</span><br><span class="hljs-attr">prefix:</span> <span class="hljs-string">/</span><br><br><span class="hljs-comment"># Enable or disable debug logging. Default is &#x27;false&#x27;.</span><br><span class="hljs-attr">debug:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Disable sniffing the files to detect their content type. Default is &#x27;false&#x27;.</span><br><span class="hljs-attr">noSniff:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Whether the server runs behind a trusted proxy or not. When this is true,</span><br><span class="hljs-comment"># the header X-Forwarded-For will be used for logging the remote addresses</span><br><span class="hljs-comment"># of logging attempts (if available).</span><br><span class="hljs-attr">behindProxy:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># The directory that will be able to be accessed by the users when connecting.</span><br><span class="hljs-comment"># This directory will be used by users unless they have their own &#x27;directory&#x27; defined.</span><br><span class="hljs-comment"># Default is &#x27;.&#x27; (current directory).</span><br><span class="hljs-attr">directory:</span> <span class="hljs-string">/data</span><br><br><span class="hljs-comment"># The default permissions for users. This is a case insensitive option. Possible</span><br><span class="hljs-comment"># permissions: C (Create), R (Read), U (Update), D (Delete). You can combine multiple</span><br><span class="hljs-comment"># permissions. For example, to allow to read and create, set &quot;RC&quot;. Default is &quot;R&quot;.</span><br><span class="hljs-attr">permissions:</span> <span class="hljs-string">R</span><br><br><span class="hljs-comment"># The default permissions rules for users. Default is none. Rules are applied</span><br><span class="hljs-comment"># from last to first, that is, the first rule that matches the request, starting</span><br><span class="hljs-comment"># from the end, will be applied to the request. Rule paths are always relative to</span><br><span class="hljs-comment"># the user&#x27;s directory.</span><br><span class="hljs-attr">rules:</span> []<br><br><span class="hljs-comment"># The behavior of redefining the rules for users. It can be:</span><br><span class="hljs-comment"># - overwrite: when a user has rules defined, these will overwrite any global</span><br><span class="hljs-comment">#   rules already defined. That is, the global rules are not applicable to the</span><br><span class="hljs-comment">#   user.</span><br><span class="hljs-comment"># - append: when a user has rules defined, these will be appended to the global</span><br><span class="hljs-comment">#   rules already defined. That is, for this user, their own specific rules will</span><br><span class="hljs-comment">#   be checked first, and then the global rules.</span><br><span class="hljs-comment"># Default is &#x27;overwrite&#x27;.</span><br><span class="hljs-attr">rulesBehavior:</span> <span class="hljs-string">overwrite</span><br><br><span class="hljs-comment"># Logging configuration</span><br><span class="hljs-attr">log:</span><br>  <span class="hljs-comment"># Logging format (&#x27;console&#x27;, &#x27;json&#x27;). Default is &#x27;console&#x27;.</span><br>  <span class="hljs-attr">format:</span> <span class="hljs-string">console</span><br>  <span class="hljs-comment"># Enable or disable colors. Default is &#x27;true&#x27;. Only applied if format is &#x27;console&#x27;.</span><br>  <span class="hljs-attr">colors:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># Logging outputs. You can have more than one output. Default is only &#x27;stderr&#x27;.</span><br>  <span class="hljs-attr">outputs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">stderr</span><br><br><span class="hljs-comment"># CORS configuration</span><br><span class="hljs-attr">cors:</span><br>  <span class="hljs-comment"># Whether or not CORS configuration should be applied. Default is &#x27;false&#x27;.</span><br>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">credentials:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">allowed_headers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Depth</span><br>  <span class="hljs-attr">allowed_hosts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">http://localhost:8080</span><br>  <span class="hljs-attr">allowed_methods:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">GET</span><br>  <span class="hljs-attr">exposed_headers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Content-Length</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Content-Range</span><br><br><span class="hljs-comment"># The list of users. If the list is empty, then there will be no authentication.</span><br><span class="hljs-comment"># Otherwise, basic authentication will automatically be configured.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If you&#x27;re delegating the authentication to a different service, you can proxy</span><br><span class="hljs-comment"># the username using basic authentication, and then disable webdav&#x27;s password</span><br><span class="hljs-comment"># check using the option:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># noPassword: true</span><br><span class="hljs-attr">users:</span><br>  <span class="hljs-comment"># Example &#x27;admin&#x27; user with plaintext password.</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">admin</span><br>  <span class="hljs-comment"># Example &#x27;john&#x27; user with bcrypt encrypted password, with custom directory.</span><br>  <span class="hljs-comment"># You can generate a bcrypt-encrypted password by using the &#x27;webdav bcrypt&#x27;</span><br>  <span class="hljs-comment"># command lint utility.</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">username:</span> <span class="hljs-string">john</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">&quot;&#123;bcrypt&#125;$2y$10$zEP6oofmXFeHaeMfBNLnP.DO8m.H.Mwhd24/TOX2MWLxAExXi4qgi&quot;</span><br>    <span class="hljs-attr">directory:</span> <span class="hljs-string">/another/path</span><br>  <span class="hljs-comment"># Example user whose details will be picked up from the environment.</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">username:</span> <span class="hljs-string">&quot;&#123;env&#125;ENV_USERNAME&quot;</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">&quot;&#123;env&#125;ENV_PASSWORD&quot;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">username:</span> <span class="hljs-string">basic</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">basic</span><br>    <span class="hljs-comment"># Override default permissions.</span><br>    <span class="hljs-attr">permissions:</span> <span class="hljs-string">CRUD</span><br>    <span class="hljs-attr">rules:</span><br>      <span class="hljs-comment"># With this rule, the user CANNOT access &#123;user directory&#125;/some/files.</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/some/file</span><br>        <span class="hljs-attr">permissions:</span> <span class="hljs-string">none</span><br>      <span class="hljs-comment"># With this rule, the user CAN create, read, update and delete within</span><br>      <span class="hljs-comment"># &#123;user directory&#125;/public/access.</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/public/access/</span><br>        <span class="hljs-attr">permissions:</span> <span class="hljs-string">CRUD</span><br>      <span class="hljs-comment"># With this rule, the user CAN read and update all files ending with .js.</span><br>      <span class="hljs-comment"># It uses a regular expression.</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">regex:</span> <span class="hljs-string">&quot;^.+.js$&quot;</span><br>        <span class="hljs-attr">permissions:</span> <span class="hljs-string">RU</span><br></code></pre></td></tr></table></figure><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><p>与多数docker容器创建相同，值得注意的是要将<code>config.yaml</code>所在目录映射进容器，并在启动参数指定<code>config</code>为容器内<code>config.yaml</code>。</p><p>参考：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name webdav-go -v /media:/data/media -v /docker/webdav:/config -p 8081:8081 --restart unless-stopped hacdias/webdav:latest -c /config/config.yaml<br></code></pre></td></tr></table></figure><h4 id="目录与端口映射"><a href="#目录与端口映射" class="headerlink" title="目录与端口映射"></a>目录与端口映射</h4><p>将想要通过webdav访问的目录映射进容器内部<code>/data</code>目录，配置文件目录<code>/docker/webdav</code>映射到容器<code>/config</code>目录，端口<code>8081</code>映射到外部。</p><h4 id="启动参数"><a href="#启动参数" class="headerlink" title="启动参数"></a>启动参数</h4><p>添加启动参数<code>-c /config/config.yaml</code>。portainer-ce安装要在Advanced container settings-Command &amp; logging设置，command设置为override并填入参数。<br><img src="/images/使用docker搭建webdav应用/portainer-ce启动参数.png" width="70%" /></p><h4 id="可访问目录"><a href="#可访问目录" class="headerlink" title="可访问目录"></a>可访问目录</h4><p>我们要将配置文件中<code>directory</code>设置为<code>/data</code>，这样才能直接访问到我们想要共享的目录。默认为<code>.</code>，此时会直接将项目<strong>根目录</strong>共享出去，这不是我们需要的。</p><h4 id="多用户"><a href="#多用户" class="headerlink" title="多用户"></a>多用户</h4><p>模板中支持对多个用户进行精细的权限控制（详见注释）。我只有一个人用，故只保留必要部分。<br>对配置文件中<code>users</code>项进行修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">users:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">username:</span> <span class="hljs-string">your_name</span>       <span class="hljs-comment"># 访问 webdav 的用户名</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">your_password</span>   <span class="hljs-comment"># 访问 webdav 的密码</span><br>    <span class="hljs-attr">directory:</span> <span class="hljs-string">/data</span>        <span class="hljs-comment"># 将 data 目录所有内容共享出来</span><br>    <span class="hljs-attr">permissions:</span> <span class="hljs-string">CRUD</span>       <span class="hljs-comment"># 对目录下文件拥有读写删改所有权限</span><br></code></pre></td></tr></table></figure><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>如果想要使用ssl反代来更安全地使用，可以在配置文件将<code>behindProxy</code>设置为<code>true</code>，在日志里就可以清晰看到访问的<strong>真实地址</strong>，否则只会是反代服务器所在的地址。</p><h2 id="挂载-webdav"><a href="#挂载-webdav" class="headerlink" title="挂载 webdav"></a>挂载 webdav</h2><p>推荐使用<code>RaiDrive</code>挂载webdav盘，<code>2020.6.36</code>前的版本没有广告。有需求可自行反代。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/hacdias/webdav">hacdias&#x2F;webdav: Simple Go WebDAV server.</a><br><a href="https://www.ztianzeng.com/post/ji-lu-yi-ci-nas-xi-tong-beng-kui/">记录一次NAS系统崩溃</a></p>]]></content>
    
    
    <summary type="html">一直想搭建好nas的webdav服务，但网上大多数服务都不支持多用户，许多人推荐的 hacdias/webdav 项目也找不到详细的安装教程，也就一直搁置了。如今终于搭建成功，便把个人的搭建流程发出来，希望能帮到有需要的人。</summary>
    
    
    
    <category term="selfhosted" scheme="https://sunjx97.github.io/categories/selfhosted/"/>
    
    
    <category term="webdav" scheme="https://sunjx97.github.io/tags/webdav/"/>
    
    <category term="docker" scheme="https://sunjx97.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>使用frp和Shadowsocks实现安全访问内网服务</title>
    <link href="https://sunjx97.github.io/posts/264d1c83/"/>
    <id>https://sunjx97.github.io/posts/264d1c83/</id>
    <published>2022-02-16T11:19:23.000Z</published>
    <updated>2025-03-13T13:23:24.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>初期自建服务器进度完成后，第二步便是实现外网对内网服务的访问（不然岂不是太过鸡肋w)。但苦于没有公网ip，传统内网穿透（如frp）把自身服务公开到公网又觉得太不安全，zerotier虚拟局域网又要频繁切换vpn很不方便，总是找不到个万全的方法，因而一直处于搁置状态。如今看到b站<code>@靛青K</code>大佬通过ss实现内网服务安全访问的方法，咱灵光一闪，想到通过frp解决没有公网ip问题，进而通过ss实现内网安全访问的思路，于是便有了这篇文章——</p><h2 id="主体思路"><a href="#主体思路" class="headerlink" title="主体思路"></a>主体思路</h2><p>通过clash实现基于域名的分流，当匹配到特定域名后缀后将流量发往ss服务端，ss服务端通过frp实现内网穿透，从而实现安全而又便捷的内网访问功能。相较于传统公网ip和frp在公网暴露服务的风险隐患，本方法<b>只允许知晓ss账号的人通过ss访问内网服务</b>，而相对于zerotier则<b>连通性更好</b>，还<b>免去了zerotier和clash不能共存的麻烦</b>，方便很多。</p><h3 id="流量整体转发路径如下"><a href="#流量整体转发路径如下" class="headerlink" title="流量整体转发路径如下"></a>流量整体转发路径如下</h3><p><code>外网访问 =&gt; clash规则匹配分流（ss客户端） =&gt; frps =&gt; frpc =&gt; ss服务端 =&gt; （ADGuard Home 自建DNS） =&gt; 反向代理服务器 =&gt; 目标服务</code></p><h2 id="Shadowsocks-服务端搭建"><a href="#Shadowsocks-服务端搭建" class="headerlink" title="Shadowsocks 服务端搭建"></a>Shadowsocks 服务端搭建</h2><p>本人使用<code>Shadowsocks-rust</code>版本，通过docker安装。其中【宿主机地址】替换为本地保存ss配置文件的目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -p 9000:9000 -p 9000:9000/udp --name shadowsocks-rust --restart=always -v 【宿主机目录】:/etc/shadowsocks-rust teddysun/shadowsocks-rust<br></code></pre></td></tr></table></figure><p>在【宿主机目录】下新建<code>config.json</code>文件，内容如下。<code>password0</code>替换为你的密码，键<code>dns</code>的值<code>192.168.1.1</code>替换为你的dns服务器地址。<code>method</code>的值<code>aes-256-gcm</code>换为你的加密方式（用咱这个就行，不用动）。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;server&quot;</span>:<span class="hljs-string">&quot;0.0.0.0&quot;</span>,<br><span class="hljs-string">&quot;server_port&quot;</span>:<span class="hljs-number">9000</span>,<br><span class="hljs-string">&quot;password&quot;</span>:<span class="hljs-string">&quot;password0&quot;</span>,<br><span class="hljs-string">&quot;timeout&quot;</span>:<span class="hljs-number">300</span>,<br><span class="hljs-string">&quot;method&quot;</span>:<span class="hljs-string">&quot;aes-256-gcm&quot;</span>,<br><span class="hljs-string">&quot;dns&quot;</span>:<span class="hljs-string">&quot;192.168.1.1&quot;</span>,<br><span class="hljs-string">&quot;mode&quot;</span>:<span class="hljs-string">&quot;tcp_and_udp&quot;</span><br></code></pre></td></tr></table></figure><p>重启shadowsocks-rust服务，ss服务端设置完成。</p><h2 id="使用frp实现内网穿透"><a href="#使用frp实现内网穿透" class="headerlink" title="使用frp实现内网穿透"></a>使用frp实现内网穿透</h2><h3 id="建立frp隧道"><a href="#建立frp隧道" class="headerlink" title="建立frp隧道"></a>建立frp隧道</h3><p>推荐使用<a href="https://www.natfrp.com/">SAKURA FRP</a>提供的免费内网穿透服务，普通用户能通过签到每日免费获取流量，内网服务的简单访问足够了（大流量或对网络要求更高的用户请自行购买流量包和VIP）。</p><p>（申请账号后）登录进入主面版，点击穿透-节点状态查看所有节点。免费用户节点有限，挑个能用的国内节点就行。<br><img src="/images/使用frp和shadowsocks实现安全访问内网服务/natfrp节点状态.png" /></p><p>转到用户-用户信息-账号信息处，找到访问密钥，记录备用。</p><p>通过id（上面节点#后即为id）选取节点，转到穿透-隧道列表-新建隧道创建隧道。选择穿透节点，tcp、udp隧道各创建一个。<br>隧道名随意设置，本地ip为<code>ss服务器ip</code>，本地端口均为<code>9000</code>（与上面ss的配置文件一致），<b>穿透节点、远程端口均一致</b>，开启压缩和加密。<br><img src="/images/使用frp和shadowsocks实现安全访问内网服务/tcp隧道建立.png" width="70%" /><br><img src="/images/使用frp和shadowsocks实现安全访问内网服务/udp隧道建立.png" width="70%" /></p><p>创建完成后，在隧道列表页获取<b>隧道id</b>。<br><img src="/images/使用frp和shadowsocks实现安全访问内网服务/获取隧道id.png" /></p><p>点其中一条隧道最后三个点（<code>操作</code>项），选择配置文件，找到<code>[common]</code>下<code>server_addr</code>项，复制frp服务器地址备用。</p><h3 id="通过docker安装frpc"><a href="#通过docker安装frpc" class="headerlink" title="通过docker安装frpc"></a>通过docker安装frpc</h3><p>因为使用的是<a href="https://doc.natfrp.com/#/frpc/usage/docker">SAKURA FRP提供的服务</a>，所以这里不能使用官方版frpc，应在dockerhub拉取<code>natfrp/frpc</code>镜像。</p><p>注意不同于官方frpc，natfrp使用用户密钥和隧道id拉取配置文件，所以要设置<a href="https://doc.natfrp.com/#/frpc/usage/docker?id=%e5%89%8d%e7%bd%ae%e7%9f%a5%e8%af%86%e8%af%b4%e6%98%8e">启动参数</a>。格式为<code>&lt;启动密钥&gt;:&lt;隧道ID1&gt;,隧道ID2,隧道ID3,...</code>，其中启动密钥即上一步的访问密钥，隧道id即上一步的两个隧道id。</p><p>使用命令行安装如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name frpc-natfrp --restart=always natfrp/frpc -f &lt;启动参数&gt;<br></code></pre></td></tr></table></figure><p>使用portainer-ce安装也可，值得注意的是运行时参数设置在Advanced container settings-Command &amp; logging设置，command设置为override并填入参数，如下图。<br><img src="/images/使用frp和shadowsocks实现安全访问内网服务/portainer-ce创建frpc容器设置.png" /></p><h2 id="clash根据规则分流"><a href="#clash根据规则分流" class="headerlink" title="clash根据规则分流"></a>clash根据规则分流</h2><p>我使用subconverter生成包含自定义规则的配置文件，subconverter可以自己搭建也能用别人搭好的，这里推荐一个<a href="https://acl4ssr-sub.github.io/">ACL4SSR 在线订阅转换</a>。远程配置使用自己的配置文件模板（可以参考大佬的模板），在<code>ruleset</code>和<code>proxy_group</code>对应添加节点和规则。配置完成后转换合并订阅即可。</p><h3 id="subconverter-配置文件模板"><a href="#subconverter-配置文件模板" class="headerlink" title="subconverter 配置文件模板"></a>subconverter 配置文件模板</h3><p>subconverter可以通过设置远程配置实现定制自己需要的规则分流。咱这里使用GitHub存储远程配置文件。<del>这里推荐直接复制大佬的模板，然后在此基础上修改。</del><br><img src="/images/使用frp和shadowsocks实现安全访问内网服务/ACL4SSR_Online配置文件.png" /></p><p>推荐几个基础模板：<br><a href="https://raw.githubusercontent.com/ACL4SSR/ACL4SSR/master/Clash/config/ACL4SSR_Online.ini">ACL4SSR_Online 默认版 分组比较全(与Github同步)</a><br><a href="https://raw.githubusercontent.com/ACL4SSR/ACL4SSR/master/Clash/config/ACL4SSR_Online_Full.ini">ACL4SSR_Online_Full 全分组 重度用户使用(与Github同步)</a></p><p>subconverter订阅转换设置细则可参考<a href="https://github.com/tindy2013/subconverter/blob/master/README-cn.md">官方使用文档</a>，这里只讲本教程需要的内容。</p><h4 id="Github-创建仓库"><a href="#Github-创建仓库" class="headerlink" title="Github 创建仓库"></a>Github 创建仓库</h4><p>（注册并）登录Github，创建仓库，创建远程配置文件<code>config.ini</code>。<del>这里太过简单直接跳过罢</del></p><h4 id="ruleset-设置"><a href="#ruleset-设置" class="headerlink" title="ruleset 设置"></a>ruleset 设置</h4><p>咱这里使用GitHub保存规则文件，同仓库下创建<code>ruleset.list</code>，填入要匹配的的域名或ip。具体规则在<a href="https://docs.cfw.lbyczf.com/contents/ui/profiles/rules.html">这里</a>。<br>我们这里直接填<code>DOMAIN-SUFFIX,your-domain.com</code>，将<code>your-domain.com</code>替换为你的域名，此行意为以<code>your-domain.com</code>为后缀的域名被匹配。最后保存，点击<code>Raw</code>获得真实地址。</p><p>复制大佬的配置模板，在配置模板中增加以下一行，<code>=</code>后面替换为你的proxy_group名称+规则地址。proxy_group和ruleset名称必须完全一致，否则会报错。注意，规则从上往下匹配，所以最好添加到一列ruleset的<b>最上方</b>。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ruleset</span>=🏠 家庭内网,https://raw.githubusercontent.com/your_account/your_project/main/rulesets/ruleset.list<br></code></pre></td></tr></table></figure><p>该条的含义是：从<code>ruleset.list</code>拉取规则，并将匹配到的流量使用<code>🏠 家庭内网</code>中选中的节点转发。</p><h4 id="proxy-group-设置"><a href="#proxy-group-设置" class="headerlink" title="proxy_group 设置"></a>proxy_group 设置</h4><p>在配置模板中增加以下一行，将<code>GROUPID=1</code>的<code>1</code>换成自己订阅链接&#x2F;节点的序号（序号<b>从0开始计算</b>）。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">custom_proxy_group</span>=🏠 家庭内网`select`!!GROUPID=<span class="hljs-number">1</span>`[]DIRECT`http://www.gstatic.com/generate_204`<span class="hljs-number">60</span>,<span class="hljs-number">5</span>,<span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><p>该条的含义是：创建一个名为<code>🏠 家庭内网</code>的代理组，使用<code>select</code>模式，添加第2条订阅和DIRECT到该节点组，延迟测速周期60秒，5秒未响应即为超时，延迟容差为50ms。</p><h4 id="获取远程配置地址"><a href="#获取远程配置地址" class="headerlink" title="获取远程配置地址"></a>获取远程配置地址</h4><p>以上两处修改完成后，GitHub创建的远程配置文件页点击<code>Raw</code>获取真实地址。</p><h3 id="Shadowsocks-节点链接生成"><a href="#Shadowsocks-节点链接生成" class="headerlink" title="Shadowsocks 节点链接生成"></a>Shadowsocks 节点链接生成</h3><p>一般使用的ss链接都经过了base64加密，我们这里先生成未加密的节点链接，再加密。</p><h4 id="获得未加密的ss链接"><a href="#获得未加密的ss链接" class="headerlink" title="获得未加密的ss链接"></a>获得未加密的ss链接</h4><p>模板：<code>method:password@hostname:port</code>。</p><p><code>method</code>是你的ss的加密方式，<code>password</code>是上面设置的密码，<code>hostname</code>和<code>port</code>是上面frp服务的地址和<b>远程</b>端口，分别替换对应内容。替换后示例<code>aes-256-gcm:barfoo@hostname:8388</code>。</p><h4 id="通过base64加密获得ss链接"><a href="#通过base64加密获得ss链接" class="headerlink" title="通过base64加密获得ss链接"></a>通过base64加密获得ss链接</h4><p>通过<a href="https://tool.chinaz.com/tools/base64.aspx">这里</a>可以便捷地实现base64加密，然后加上<code>ss://</code>大功告成，可以额外添加<code>#节点名称</code>来给自己的ss节点命名。</p><h3 id="通过-subconverter-生成全新订阅"><a href="#通过-subconverter-生成全新订阅" class="headerlink" title="通过 subconverter 生成全新订阅"></a>通过 subconverter 生成全新订阅</h3><p>使用推荐的<a href="https://acl4ssr-sub.github.io/">ACL4SSR 在线订阅转换</a>生成全新订阅。<br>在订阅链接处<b>按次序</b>填好机场订阅链接和ss链接，在订阅转换的远程配置处粘贴上面得到的远程配置地址，点生成订阅链接即可。</p><img src="/images/使用frp和shadowsocks实现安全访问内网服务/subconverter生成订阅.png"/><h2 id="DNS-服务器设置"><a href="#DNS-服务器设置" class="headerlink" title="DNS 服务器设置"></a>DNS 服务器设置</h2><p>这里使用ADGuard Home做DNS服务，ADGuard Home的DNS重写可以看作自定义hosts功能。选择过滤器-DNS重写，添加DNS重写，ip为反向代理服务器的ip。ADGuard Home这里支持泛域名，好评！<br><img src="/images/使用frp和shadowsocks实现安全访问内网服务/DNS重写.png" /></p><h3 id="内网流量转发设置"><a href="#内网流量转发设置" class="headerlink" title="内网流量转发设置"></a>内网流量转发设置</h3><p>现在，你已经可以实现外网访问本地内网服务了。但内网设备clash也会绕这么大一圈来访问内网服务，这不符合我们的初衷。这就需要我们对内网流量转发做额外设置，</p><h3 id="DNS-服务器设置-1"><a href="#DNS-服务器设置-1" class="headerlink" title="DNS 服务器设置"></a>DNS 服务器设置</h3><p>我们在DNS重写中，添加域名为frp服务器的域名，ip为反代服务器的ip。</p><h3 id="反代设置-Streams-流量转发"><a href="#反代设置-Streams-流量转发" class="headerlink" title="反代设置 Streams 流量转发"></a>反代设置 Streams 流量转发</h3><p>这里通过Nginx Proxy Manager设置，没有搭建的同学可以查看咱之前的搭建教程：<a href="https://sunjx97.github.io/posts/233f7ebd/">《使用docker搭建nginx proxy manager实现反向代理和SSL证书申请》</a>。</p><p>Nginx的Stream模块工作在第四层，我们可以用来转发tcp、udp数据包。登录管理页面，点击Streams-Add Stream，<code>Incoming Port</code>填frp隧道的<b>远程端口</b>，<code>Forward Host</code>填ss服务端的ip，<code>Forward Port</code>填ss服务端的端口（即上面设置的<code>9000</code>）。</p><p>设置完毕，此时如果我们回到家里，也不用手动切换为DIRECT，访问内网服务的数据会自动导向反代服务器，进而转发到ss服务回到内网，无需担心浪费frp的流量。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此，本教程终于结束了。对于内外网两栖的设备在节点组需要选择自己的ss节点，而内网设备直接选择DIRECT即可，DNS和反代服务器会将流量转发到正确的服务ip和端口。相对于<code>@靛青K</code>大佬直接使用ddns和公网ip搭建ss服务端，这个方法肯定麻烦许多，但对于当前ipv6未全面铺开的情况和大内网的我来说，终归是够用了。<del>所以ipv6时代什么时候来啊(#&#96;O′)&#x2F;</del></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/read/cv9219407">使用 Shadowsocks 访问家庭内网</a><br><a href="https://doc.natfrp.com/#/frpc/usage/docker">使用 docker 管理 frpc 运行 - SAKURA FRP</a><br><a href="https://github.com/tindy2013/subconverter/blob/master/README-cn.md">subconverter 官方使用文档</a><br><a href="https://docs.cfw.lbyczf.com/contents/ui/profiles/rules.html">规则编辑 - Clash for Windows</a><br><a href="https://blog.kelu.org/tech/2017/04/25/generate-shadowsocks-qrcode.html">shadowsocks 生成二维码 URI</a><br><a href="https://yjdwbj.github.io/2020/02/12/%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%A4%96VPS%E6%8C%87%E5%8D%97-Linode/#URI%E4%B8%8E%E4%BA%8C%E7%BB%B4%E7%A0%81">URI与二维码 - shadowsocks-libev</a></p>]]></content>
    
    
    <summary type="html">初期自建服务器进度完成后，第二步便是实现外网对内网服务的访问（不然岂不是太过鸡肋w)。但苦于总是找不到个万全的方法，因而一直处于搁置状态。如今看到b站 @靛青K 大佬通过ss实现内网服务安全访问的方法，咱灵光一闪，想到通过frp解决没有公网ip问题，进而通过ss实现内网安全访问的思路，于是便有了这篇文章——</summary>
    
    
    
    <category term="selfhosted" scheme="https://sunjx97.github.io/categories/selfhosted/"/>
    
    
    <category term="内网穿透" scheme="https://sunjx97.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
    <category term="frp" scheme="https://sunjx97.github.io/tags/frp/"/>
    
    <category term="Shadowsocks" scheme="https://sunjx97.github.io/tags/Shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>解决transmission使用网络共享的监控目录时的监控失灵问题</title>
    <link href="https://sunjx97.github.io/posts/7133bd05/"/>
    <id>https://sunjx97.github.io/posts/7133bd05/</id>
    <published>2022-01-07T15:11:08.000Z</published>
    <updated>2022-02-18T12:45:23.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>transmission可以通过设置watch监控文件夹来自动添加监控目录内的种子，但如果监控文件夹是smb共享，则会出现失灵的现象（即只在开启或重启时添加一次目录内的种子）。本人使用NAS集中管理自己的数据，docker版transmission也是映射的主机挂载的smb共享文件夹，便出现了日常使用不自动添加种子的问题。</p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>transmission在Linux下默认使用inotify监控监控目录，而inotify不对cifs共享有效。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在配置文件目录的settings.json加入下行即可。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;watch-dir-force-generic&quot;</span>: <span class="literal">true</span>,</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://forum.transmissionbt.com/viewtopic.php?t=17960">Watch-dir on network folder</a></p>]]></content>
    
    
    <summary type="html">Linux下使用transmission时，其监控文件夹功能会在监控smb共享文件夹时失效。</summary>
    
    
    
    <category term="selfhosted" scheme="https://sunjx97.github.io/categories/selfhosted/"/>
    
    
    <category term="transmission" scheme="https://sunjx97.github.io/tags/transmission/"/>
    
    <category term="pt" scheme="https://sunjx97.github.io/tags/pt/"/>
    
    <category term="smb" scheme="https://sunjx97.github.io/tags/smb/"/>
    
  </entry>
  
  <entry>
    <title>解决通过fstab开机挂载smb文件夹导致的Database is locked问题</title>
    <link href="https://sunjx97.github.io/posts/cbb0bc9e/"/>
    <id>https://sunjx97.github.io/posts/cbb0bc9e/</id>
    <published>2022-01-04T05:38:54.000Z</published>
    <updated>2022-02-18T12:45:23.859Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>发现在使用fstab开机挂载的smb文件夹会有Database is locked的问题，如通过docker安装的nginx-proxy-manager和qiandao，映射的文件夹是smb（cifs）共享挂载的，因为默认使用了sqlite的数据库，会导致Database is locked问题，如下图：</p><img src="/images/解决通过fstab开机挂载smb文件夹导致的Database-is-locked问题/sqlite报错 01.png" width="70%" /><img src="/images/解决通过fstab开机挂载smb文件夹导致的Database-is-locked问题/sqlite报错 02.png" /><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在挂载时加入<b>nolock</b>参数即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//myserver /mymount cifs username=**,password=**,nolock,uid=1000,gid=1000</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.archiware.com/blog/pure_forum/pure-question-answers/database-is-locked/">Database is locked</a></p>]]></content>
    
    
    <summary type="html">发现在使用fstab开机挂载时，使用sqlite的数据库，有时会导致Database is locked问题，这时需要通过添加参数来解决。</summary>
    
    
    
    <category term="selfhosted" scheme="https://sunjx97.github.io/categories/selfhosted/"/>
    
    
    <category term="docker" scheme="https://sunjx97.github.io/tags/docker/"/>
    
    <category term="smb" scheme="https://sunjx97.github.io/tags/smb/"/>
    
    <category term="sqlite" scheme="https://sunjx97.github.io/tags/sqlite/"/>
    
  </entry>
  
  <entry>
    <title>蜗牛星际A款机箱的六盘位改造</title>
    <link href="https://sunjx97.github.io/posts/b040efc9/"/>
    <id>https://sunjx97.github.io/posts/b040efc9/</id>
    <published>2022-01-01T12:46:11.000Z</published>
    <updated>2022-02-18T12:45:23.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>距离改造已经过去很久了，直到现在才发出来_(:3」∠)_</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>因为蜗牛星际A款机箱本来就带一个2.5寸硬盘位（机箱内部），所以只要再扩展出一个2.5寸硬盘位即可。</p><p>用到了一个2.5寸硬盘支架，购买链接在<a href="https://item.taobao.com/item.htm?id=605572434546">这里</a>，购买半高PCIe款。</p><p>使用的螺丝购买链接在<a href="https://detail.tmall.com/item.htm?id=606010296755">这里</a>，<b>规格为M3</b>，建议买短点。</p><ol><li><p>先用四个螺丝将支架和硬盘固定（硬盘有一面有四个螺丝孔），我这边买的螺丝比较长，所以用螺母当垫片使用。</p><img src="/images/蜗牛星际A款机箱的六盘位改造/增加2.5寸盘位 01.jpg" /></li><li><p>因为螺丝本身有厚度，所以支架最底下那个盘位要空出来，直接在第二个盘位安装2.5寸硬盘即可。</p><img src="/images/蜗牛星际A款机箱的六盘位改造/增加2.5寸盘位 02.jpg" /><img src="/images/蜗牛星际A款机箱的六盘位改造/增加2.5寸盘位 03.jpg" /></li></ol><p>成品如图：<br><img src="/images/蜗牛星际A款机箱的六盘位改造/增加2.5寸盘位 04.jpg" /><br><img src="/images/蜗牛星际A款机箱的六盘位改造/增加2.5寸盘位 05.jpg" /></p><p>大概只能扩充到2个2.5寸盘位，毕竟离机箱壁太近了。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>机箱内部的2.5寸盘位因为要将4个螺丝孔那面对外，所以<b>对硬盘厚度有要求</b>，建议厚盘装在外面。</p>]]></content>
    
    
    <summary type="html">蜗牛星际A款机箱改造6盘位（4个3.5寸盘位+2个2.5寸盘位）</summary>
    
    
    
    <category term="DIY" scheme="https://sunjx97.github.io/categories/DIY/"/>
    
    
    <category term="蜗牛星际" scheme="https://sunjx97.github.io/tags/%E8%9C%97%E7%89%9B%E6%98%9F%E9%99%85/"/>
    
    <category term="DIY" scheme="https://sunjx97.github.io/tags/DIY/"/>
    
  </entry>
  
  <entry>
    <title>使用docker搭建nginx proxy manager实现反向代理和SSL证书申请</title>
    <link href="https://sunjx97.github.io/posts/233f7ebd/"/>
    <id>https://sunjx97.github.io/posts/233f7ebd/</id>
    <published>2022-01-01T03:12:37.000Z</published>
    <updated>2022-07-10T02:59:53.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自从入坑NAS以来，（黑）群晖一直都是我文件存储管理的得力助手。但随着我的<del>圈内吹水日益熟练</del>学习和理解不断加深，黑裙已不能满足我的需求。如今，是时候告别（黑）群晖，往更专业的自建服务器方向发展了。其中关键的一步，便是找到能方便替换群晖反向代理服务的开源项目，而nginx proxy manager给了我一个很好的选择。</p><h2 id="nginx-proxy-manager介绍"><a href="#nginx-proxy-manager介绍" class="headerlink" title="nginx proxy manager介绍"></a>nginx proxy manager介绍</h2><p>nginx proxy manager能让我们轻松地转发到在家里或其他地方运行的网站，包括免费的SSL，而不需要对Nginx或Letsencrypt了解太多。便捷直观的web页面管理和操作无疑大大简化了一般nginx反代服务的步骤。</p><h2 id="docker安装nginx-proxy-manager"><a href="#docker安装nginx-proxy-manager" class="headerlink" title="docker安装nginx proxy manager"></a>docker安装nginx proxy manager</h2><p>推荐使用docker-compose安装</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">app:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">&#x27;jc21/nginx-proxy-manager:latest&#x27;</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-comment"># These ports are in format &lt;host-port&gt;:&lt;container-port&gt;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;80:80&#x27;</span> <span class="hljs-comment"># Public HTTP Port</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;443:443&#x27;</span> <span class="hljs-comment"># Public HTTPS Port</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;81:81&#x27;</span> <span class="hljs-comment"># Admin Web Port</span><br>      <span class="hljs-comment"># Add any other Stream port you want to expose</span><br>      <span class="hljs-comment"># - &#x27;21:21&#x27; # FTP</span><br><br>    <span class="hljs-comment"># Uncomment the next line if you uncomment anything in the section</span><br>    <span class="hljs-comment"># environment:</span><br>      <span class="hljs-comment"># Uncomment this if you want to change the location of </span><br>      <span class="hljs-comment"># the SQLite DB file within the container</span><br>      <span class="hljs-comment"># DB_SQLITE_FILE: &quot;/data/database.sqlite&quot;</span><br><br>      <span class="hljs-comment"># Uncomment this if IPv6 is not enabled on your host</span><br>      <span class="hljs-comment"># DISABLE_IPV6: &#x27;true&#x27;</span><br><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./data:/data</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./letsencrypt:/etc/letsencrypt</span><br></code></pre></td></tr></table></figure><p>浏览器输入【docker主机ip:81】，成功进入web页面，初次登录使用邮箱：<a href="mailto:&#97;&#100;&#109;&#105;&#x6e;&#x40;&#101;&#120;&#97;&#x6d;&#112;&#108;&#101;&#x2e;&#99;&#111;&#x6d;">&#97;&#100;&#109;&#105;&#x6e;&#x40;&#101;&#120;&#97;&#x6d;&#112;&#108;&#101;&#x2e;&#99;&#111;&#x6d;</a>，密码：changeme。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/通过docker安装nginx proxy manager 01.png" /></p><p>登录进去后会让你设置管理员的用户名（Full Name），昵称（Nickname）和邮箱。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/通过docker安装nginx proxy manager 02.png" width="60%" /></p><p>接下来设置密码，旧密码即预设密码changeme。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/通过docker安装nginx proxy manager 03.png" width="60%" /></p><p>至此，nginx proxy manager初始化完成。</p><h2 id="使用nginx-proxy-manager实现反向代理"><a href="#使用nginx-proxy-manager实现反向代理" class="headerlink" title="使用nginx proxy manager实现反向代理"></a>使用nginx proxy manager实现反向代理</h2><p>登录进入主面版，点击Proxy Hosts转到反向代理设置界面。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/nginx proxy manager反向代理 01.png" /></p><p>点击Add Proxy Host，添加一个反向代理。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/nginx proxy manager反向代理 02.png" /></p><p>在Details页面，Domain Names填写你的域名，Scheme填写反代对象的协议（http&#x2F;https），Forward Hostname&#x2F;IP填写反代对象的地址，Forward Port填写反代对象的端口号。</p><p><code>Domain Names</code> - 填写需要反代的域名<br><code>Scheme</code> - 选择来源的协议<br><code>Forward Hostname / IP</code> - 填写来源的主机名或IP<br><code>Forward Port</code> - 填写来源的端口<br><code>Cache Assets</code> - 是否启用缓存<br><code>Block Common Expoits</code> - 阻止常见的漏洞<br><code>Websockets Support</code> - 是支援 Websockets<br><code>Access List</code> - 权限列表选择，可以给反代的网页设置账户密码，验证通过后才能正常打开</p><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/nginx proxy manager反向代理 03.png" width="60%" /><p>如果有https加密需求，转到SSL页面，将SSL Certificate选择为你申请的证书，建议勾选SSL Force（强制SSL）。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/nginx proxy manager反向代理 04.png" width="60%" /></p><p>点击保存，在反向代理页面可以看到刚刚设置的反向代理。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/nginx proxy manager反向代理 05.png" /></p><p>测试相应网站，反代成功。</p><h2 id="SSL证书申请"><a href="#SSL证书申请" class="headerlink" title="SSL证书申请"></a>SSL证书申请</h2><h3 id="HTTP-01-验证方式"><a href="#HTTP-01-验证方式" class="headerlink" title="HTTP-01 验证方式"></a>HTTP-01 验证方式</h3><p>最简单常规的SSL证书申请方式，如果你的主机可以放行80端口（如在各大公有云处购买的主机），推荐使用这种方式。<del>我这边没有虚拟主机，家用80端口也被封锁了，所以也没用过这种方式，姑且放在这里给大家参考_(:3」∠)_</del></p><p>转到反代编辑页面，在SSL页面选择Request a new SSL Certificate，建议勾选SSL Force（强制SSL），打开勾选I Agree to the Let’s Encrypt Terms of Service同意Let’s Encrypt相关条款，点击保存。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/nginx proxy manager设置SSL证书 HTTP-01.png" width="60%" /></p><p>可以看到反代已自动申请SSL证书，可以通过https访问了。证书有效期3个月，到期会自动续期。</p><h3 id="DNS-01-验证方式"><a href="#DNS-01-验证方式" class="headerlink" title="DNS-01 验证方式"></a>DNS-01 验证方式</h3><p>因为国内ISP一般都封锁了80端口，所以HTTP-01验证方式大概率在家庭自建服务器的情况下不会成功。作为替代，我们可以选择使用DNS-01的验证方式来申请SSL证书。相较于HTTP-01，DNS-01可以申请<a href="https://letsencrypt.org/zh-cn/docs/challenge-types/">支持通配符的域名证书</a>，也算弥补了其操作繁琐的缺点。这里以DNSPOD和CloudFlare为例：</p><h4 id="·-DNSPOD"><a href="#·-DNSPOD" class="headerlink" title="· DNSPOD"></a>· DNSPOD</h4><h5 id="1-申请api-key"><a href="#1-申请api-key" class="headerlink" title="1. 申请api key"></a>1. 申请api key</h5><p>首先登录DNSPOD控制台，在右上角找到 API密钥 项。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/DNSPOD API申请 01.png" width="50%" /></p><p>转到 DNSPod Token 页面，点击创建密钥。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/DNSPOD API申请 02.png" width="60%" /></p><p>设置密钥名称<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/DNSPOD API申请 03.png" width="60%" /></p><p>查看并保存ID和Token项，这里的内容<b>只会显示一次</b>，一定要保存好。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/DNSPOD API申请 04.png" width="60%" /></p><p>已经能在总览看到相关API已申请成功。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/DNSPOD API申请 05.png" /></p><h5 id="2-配置nginx-proxy-manager并申请SSL证书"><a href="#2-配置nginx-proxy-manager并申请SSL证书" class="headerlink" title="2. 配置nginx proxy manager并申请SSL证书"></a>2. 配置nginx proxy manager并申请SSL证书</h5><p>点击SSL Certificates，转到SSL Certificates页面；再点击右上角Add SSL Certificate，选择Let’s Encrypt。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/nginx proxy manager设置SSL证书 DNS-01 01.png" /></p><p>如下图，Domain names填写自己的域名，Email Address for Let’s Encrypt填写自己的邮箱。</p><p>打开Use a DNS Challenge，DNS Provider选择DNSPod，将dns_dnspod_email中的<a href="mailto:&#101;&#109;&#x61;&#x69;&#x6c;&#x40;&#101;&#x78;&#97;&#x6d;&#x70;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;">&#101;&#109;&#x61;&#x69;&#x6c;&#x40;&#101;&#x78;&#97;&#x6d;&#x70;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;</a>替换为DNSPod的邮箱，dns_dnspod_api_token中的id,key对应填入（即在上一步申请得到的id和token），注意不要删掉英文双引号，且id与token用英文逗号连接。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">dns_dnspod_email</span> = <span class="hljs-string">&quot;email@example.com&quot;</span><br><span class="hljs-attr">dns_dnspod_api_token</span> = <span class="hljs-string">&quot;id,key&quot;</span><br></code></pre></td></tr></table></figure><p>勾选I Agree to the Let’s Encrypt Terms of Service同意Let’s Encrypt相关条款，点击保存。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/nginx proxy manager设置SSL证书 DNS-01 02.png" /></p><p>可以看到SSL证书已经申请完成，有效期3个月，到期会自动续期。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/nginx proxy manager设置SSL证书 DNS-01 03.png" /></p><h4 id="·-CloudFlare"><a href="#·-CloudFlare" class="headerlink" title="· CloudFlare"></a>· CloudFlare</h4><h5 id="1-获取api-key"><a href="#1-获取api-key" class="headerlink" title="1. 获取api key"></a>1. 获取api key</h5><p>打开<a href="https://dash.cloudflare.com/profile/api-tokens">个人资料-API令牌</a>，找到<b>API 密钥</b>，查看并复制<b>Global API Key</b>。</p><h5 id="2-配置nginx-proxy-manager并申请SSL证书-1"><a href="#2-配置nginx-proxy-manager并申请SSL证书-1" class="headerlink" title="2. 配置nginx proxy manager并申请SSL证书"></a>2. 配置nginx proxy manager并申请SSL证书</h5><p>同上，不过要将申请信息进行替换（初始的只有api token的形式申请会有问题）。<a href="mailto:&#x73;&#111;&#x6d;&#101;&#x74;&#x68;&#x69;&#x6e;&#x67;&#64;&#x68;&#111;&#116;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;">&#x73;&#111;&#x6d;&#101;&#x74;&#x68;&#x69;&#x6e;&#x67;&#64;&#x68;&#111;&#116;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;</a>替换为cloudflare的邮箱，0123456789abcdef0123456789abcdef01234567替换为上面得到的Global API Key。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># Cloudflare API token</span><br><span class="hljs-attr">dns_cloudflare_email</span> = something@hotmail.com<br><span class="hljs-attr">dns_cloudflare_api_key</span> = <span class="hljs-number">0123456789</span>abcdef0123456789abcdef01234567<br></code></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="需要开启Websockets-Support的应用-x2F-网站"><a href="#需要开启Websockets-Support的应用-x2F-网站" class="headerlink" title="需要开启Websockets Support的应用&#x2F;网站"></a>需要开启Websockets Support的应用&#x2F;网站</h3><p>Proxmox VE：不开启会导致novnc连接错误<br>jlesage&#x2F;jdownloader-2：不开启会无法进入webui管理页面<br>truenas：不开启会导致webui无法登录<br>portainer&#x2F;portainer-ce：不开启无法对容器使用console</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://nginxproxymanager.com/guide/#project-goal">Nginx Proxy Manager</a><br><a href="https://letsencrypt.org/zh-cn/docs/challenge-types/">验证方式 - Let’s Encrypt</a><br><a href="https://www.bilibili.com/video/BV1Gg411w7kQ">【Docker系列】一个反向代理神器——Nginx Proxy Manager</a><br><a href="https://blog.laoda.de/archives/nginxproxymanager">【Docker系列】一个反向代理神器——Nginx Proxy Manager</a><br><a href="https://www.jianshu.com/p/659dc904967f">certbot dns插件</a><br><a href="https://github.com/NginxProxyManager/nginx-proxy-manager/issues/680#issuecomment-722016183">Cannot get Let’s Encrypt cert via cloudflare dns challange</a><br><a href="https://www.sio.moe/2021/12/18/computer/Docker-Container/Use-Docker-to-install-Nginx-ProxyManager-for-SSL-reverse-proxy/">使用Docker安裝Nginx-ProxyManager進行SSL反向代理</a></p>]]></content>
    
    
    <summary type="html">自从入坑NAS以来，（黑）群晖一直都是我文件存储管理的得力助手。但随着我的学习和理解不断加深，黑裙已不能满足我的需求。如今，是时候告别（黑）群晖，往更专业的自建服务器方向发展了。其中关键的一步，便是找到能方便替换群晖反向代理服务的开源项目，而nginx proxy manager给了我一个很好的选择。</summary>
    
    
    
    <category term="selfhosted" scheme="https://sunjx97.github.io/categories/selfhosted/"/>
    
    
    <category term="反向代理" scheme="https://sunjx97.github.io/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
    <category term="SSL" scheme="https://sunjx97.github.io/tags/SSL/"/>
    
  </entry>
  
  <entry>
    <title>Transmission 2.94升级3.00 跳过启动校验</title>
    <link href="https://sunjx97.github.io/posts/402aacbe/"/>
    <id>https://sunjx97.github.io/posts/402aacbe/</id>
    <published>2021-12-18T12:13:22.000Z</published>
    <updated>2022-03-11T04:11:21.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>将transmission升级到了3.00，发现每次启动都会对升级前的旧种子重新校验，然后就是数十个小时的校验过程，实在让人头大。经过多次尝试，终于找到可以跳过启动校验（只校验一次）的方法了，现记录如下。</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>transmission在3.00使用<b>40位hash</b>记录种子文件的信息（之前是16位），在torrents和resume文件夹中新生成的文件都是用40位hash值命名的。要解决每次启动都重复校验的问题，需要将旧种子的信息更新。主要有以下几步：</p><ol><li>等待transmission第一次校验完生成<b>新的40位hash命名的resume文件</b>并将旧种子的的resume文件删除</li><li>将对应的旧种子的torrent文件更名为<b>相同的40位hash</b>。</li></ol><h3 id="等待初次校验完成"><a href="#等待初次校验完成" class="headerlink" title="等待初次校验完成"></a>等待初次校验完成</h3><img src="/images/Transmission-2-94升级3-00-跳过启动校验/resume新旧文件对比.png" width="70%" /><p>等待校验完成并删除旧resume文件（很好分辨，2.94版本是【种子名+前16位hash】的命名方式，而3.0版本生成的新resume文件都是【40位hash】命名方式）</p><h3 id="对旧torrent文件重命名"><a href="#对旧torrent文件重命名" class="headerlink" title="对旧torrent文件重命名"></a>对旧torrent文件重命名</h3><p>停止docker中的transmission服务，将旧torrent文件重命名为新40位hash形式。<br>因为旧torrent文件名称包含前16位hash，所以可以直接将16位hash字符串与resume文件夹内所有文件进行匹配，如果匹配上前16位，则修正命名。</p><p>写了段<a href="https://github.com/sunjx97/torrent-file-rename">代码</a>解决命名问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">torrents_src = <span class="built_in">input</span>(<span class="string">&#x27;请输入torrents文件夹绝对路径：&#x27;</span>)</span><br><span class="line">resume_src = <span class="built_in">input</span>(<span class="string">&#x27;请输入resume文件夹绝对路径：&#x27;</span>)</span><br><span class="line"></span><br><span class="line">torrent_list = os.listdir(torrents_src)</span><br><span class="line">resume_list = os.listdir(resume_src)</span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> torrent <span class="keyword">in</span> torrent_list:</span><br><span class="line">    <span class="comment"># 从16位hash值开始，到后缀名结束</span></span><br><span class="line">    <span class="comment"># 如果是新版文件40位hash，则会截取后16位，在下面match起始位置匹配匹配失败</span></span><br><span class="line">    pattern = torrent[-<span class="number">24</span>:-<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> resume <span class="keyword">in</span> resume_list:</span><br><span class="line">        <span class="keyword">if</span> re.match(pattern, resume[:-<span class="number">7</span>], re.I):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Ok, find the files!&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;torrent:&#x27;</span>, torrent)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;resume:&#x27;</span>, resume)</span><br><span class="line">            os.rename(torrents_src+<span class="string">&#x27;\\&#x27;</span>+torrent, torrents_src+<span class="string">&#x27;\\&#x27;</span>+resume[:-<span class="number">7</span>]+<span class="string">&#x27;.torrent&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;torrent&#125;</span> 已更名为 <span class="subst">&#123;resume[:-<span class="number">7</span>]&#125;</span>.torrent&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;==========================&#x27;</span>)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;已成功命名<span class="subst">&#123;count&#125;</span>个种子文件&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行结果如下，一切顺利。<br><img src="/images/Transmission-2-94升级3-00-跳过启动校验/torrent更名成功.png" /></p><p>启动transmission，可以看到已经没有在校验了。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>在操作前<b>备份</b>好torrents和resume文件夹</li><li>初次校验完成后建议<b>停止</b>transmission服务后再操作。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/ylxb2016/PT-help/blob/master/PT%20Tutorial/%E3%80%90%E5%8E%9F%E5%88%9B%E3%80%91Transmission%20%E6%89%8B%E5%8A%A8%E8%B7%B3%E8%BF%87%E6%A0%A1%E9%AA%8C%20%E6%95%99%E7%A8%8B.md">【原创】Transmission 手动跳过校验 教程.md</a><br><a href="https://forum.transmissionbt.com/viewtopic.php?f=2&t=20838&p=80079&hilit=resume&sid=6a23eb2473eab4b32c5df60332c16ae1">Move a half downloaded file from Android to Windows&#x2F;Linux</a><br><a href="https://forum.transmissionbt.com/viewtopic.php?f=2&t=20694&p=79636&hilit=resume&sid=6a23eb2473eab4b32c5df60332c16ae1#p79636">Reinstall Transmission and moving data to avoid torrent recheck</a></p>]]></content>
    
    
    <summary type="html">将transmission升级到了3.00，发现每次启动都会对升级前的旧种子重新校验，然后就是数十个小时的校验过程，实在让人头大。经过多次尝试，终于找到可以跳过启动校验（只校验一次）的方法了，现记录如下。</summary>
    
    
    
    <category term="pt" scheme="https://sunjx97.github.io/categories/pt/"/>
    
    
    <category term="transmission" scheme="https://sunjx97.github.io/tags/transmission/"/>
    
    <category term="pt" scheme="https://sunjx97.github.io/tags/pt/"/>
    
  </entry>
  
</feed>
