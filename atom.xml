<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sunjx97&#39;s Blog</title>
  
  
  <link href="https://sunjx97.github.io/atom.xml" rel="self"/>
  
  <link href="https://sunjx97.github.io/"/>
  <updated>2022-02-17T06:44:55.326Z</updated>
  <id>https://sunjx97.github.io/</id>
  
  <author>
    <name>sunjx97</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用frp和Shadowsocks实现安全访问内网服务</title>
    <link href="https://sunjx97.github.io/2022/02/16/%E4%BD%BF%E7%94%A8frp%E5%92%8Cshadowsocks%E5%AE%9E%E7%8E%B0%E5%AE%89%E5%85%A8%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E6%9C%8D%E5%8A%A1/"/>
    <id>https://sunjx97.github.io/2022/02/16/%E4%BD%BF%E7%94%A8frp%E5%92%8Cshadowsocks%E5%AE%9E%E7%8E%B0%E5%AE%89%E5%85%A8%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E6%9C%8D%E5%8A%A1/</id>
    <published>2022-02-16T11:19:23.000Z</published>
    <updated>2022-02-17T06:44:55.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>初期自建服务器进度完成后，第二步便是实现外网对内网服务的访问（不然岂不是太过鸡肋w)。但苦于没有公网ip，传统内网穿透（如frp）把自身服务公开到公网又觉得太不安全，zerotier虚拟局域网又要频繁切换vpn很不方便，总是找不到个万全的方法，因而一直处于搁置状态。如今看到b站<code>@靛青K</code>大佬通过ss实现内网服务安全访问的方法，咱灵光一闪，想到通过frp解决没有公网ip问题，进而通过ss实现内网安全访问的思路，于是便有了这篇文章——</p><h2 id="主体思路"><a href="#主体思路" class="headerlink" title="主体思路"></a>主体思路</h2><p>通过clash实现基于域名的分流，当匹配到特定域名后缀后将流量发往ss服务端，ss服务端通过frp实现内网穿透，从而实现安全而又便捷的内网访问功能。相较于传统公网ip和frp在公网暴露服务的风险隐患，本方法<b>只允许知晓ss账号的人通过ss访问内网服务</b>，而相对于zerotier则<b>连通性更好</b>，还<b>免去了zerotier和clash不能共存的麻烦</b>，方便很多。</p><h3 id="流量整体转发路径如下"><a href="#流量整体转发路径如下" class="headerlink" title="流量整体转发路径如下"></a>流量整体转发路径如下</h3><p><code>外网访问 =&gt; clash规则匹配分流（ss客户端） =&gt; frps =&gt; frpc =&gt; ss服务端 =&gt; （ADGuard Home 自建DNS） =&gt; 反向代理服务器 =&gt; 目标服务</code></p><h2 id="Shadowsocks-服务端搭建"><a href="#Shadowsocks-服务端搭建" class="headerlink" title="Shadowsocks 服务端搭建"></a>Shadowsocks 服务端搭建</h2><p>本人使用<code>Shadowsocks-rust</code>版本，通过docker安装。其中【宿主机地址】替换为本地保存ss配置文件的目录。</p><p><code>docker run -d -p 9000:9000 -p 9000:9000/udp --name shadowsocks-rust --restart=always -v 【宿主机目录】:/etc/shadowsocks-rust teddysun/shadowsocks-rust</code></p><p>在【宿主机目录】下新建<code>config.json</code>文件，内容如下。<code>password0</code>替换为你的密码，键<code>dns</code>的值<code>192.168.1.1</code>替换为你的dns服务器地址。<code>method</code>的值<code>aes-256-gcm</code>换为你的加密方式（用咱这个就行，不用动）。</p><figure class="highlight json"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;server&quot;</span>:<span class="hljs-string">&quot;0.0.0.0&quot;</span>,<br><span class="hljs-string">&quot;server_port&quot;</span>:<span class="hljs-number">9000</span>,<br><span class="hljs-string">&quot;password&quot;</span>:<span class="hljs-string">&quot;password0&quot;</span>,<br><span class="hljs-string">&quot;timeout&quot;</span>:<span class="hljs-number">300</span>,<br><span class="hljs-string">&quot;method&quot;</span>:<span class="hljs-string">&quot;aes-256-gcm&quot;</span>,<br><span class="hljs-string">&quot;dns&quot;</span>:<span class="hljs-string">&quot;192.168.1.1&quot;</span>,<br><span class="hljs-string">&quot;mode&quot;</span>:<span class="hljs-string">&quot;tcp_and_udp&quot;</span><br></code></pre></td></tr></table></figure><p>重启shadowsocks-rust服务，ss服务端设置完成。</p><h2 id="使用frp实现内网穿透"><a href="#使用frp实现内网穿透" class="headerlink" title="使用frp实现内网穿透"></a>使用frp实现内网穿透</h2><h3 id="建立frp隧道"><a href="#建立frp隧道" class="headerlink" title="建立frp隧道"></a>建立frp隧道</h3><p>推荐使用<a href="https://www.natfrp.com/">SAKURA FRP</a>提供的免费内网穿透服务，普通用户能通过签到每日免费获取流量，内网服务的简单访问足够了（大流量或对网络要求更高的用户请自行购买流量包和VIP）。</p><p>（申请账号后）登录进入主面版，点击穿透-节点状态查看所有节点。免费用户节点有限，挑个能用的国内节点就行。<br><img src="/images/使用frp和shadowsocks实现安全访问内网服务/natfrp节点状态.png" /></p><p>转到用户-用户信息-账号信息处，找到访问密钥，记录备用。</p><p>通过id（上面节点#后即为id）选取节点，转到穿透-隧道列表-新建隧道创建隧道。选择穿透节点，tcp、udp隧道各创建一个。<br>隧道名随意设置，本地ip为<code>ss服务器ip</code>，本地端口均为<code>9000</code>（与上面ss的配置文件一致），<b>穿透节点、远程端口均一致</b>，开启压缩和加密。<br><img src="/images/使用frp和shadowsocks实现安全访问内网服务/tcp隧道建立.png" width="70%" /><br><img src="/images/使用frp和shadowsocks实现安全访问内网服务/udp隧道建立.png" width="70%" /></p><p>创建完成后，在隧道列表页获取<b>隧道id</b>。<br><img src="/images/使用frp和shadowsocks实现安全访问内网服务/获取隧道id.png" /></p><p>点其中一条隧道最后三个点（<code>操作</code>项），选择配置文件，找到<code>[common]</code>下<code>server_addr</code>项，复制frp服务器地址备用。</p><h3 id="通过docker安装frpc"><a href="#通过docker安装frpc" class="headerlink" title="通过docker安装frpc"></a>通过docker安装frpc</h3><p>因为使用的是<a href="https://doc.natfrp.com/#/frpc/usage/docker">SAKURA FRP提供的服务</a>，所以这里不能使用官方版frpc，应在dockerhub拉取<code>natfrp/frpc</code>镜像。</p><p>注意不同于官方frpc，natfrp使用用户密钥和隧道id拉取配置文件，所以要设置<a href="https://doc.natfrp.com/#/frpc/usage/docker?id=%e5%89%8d%e7%bd%ae%e7%9f%a5%e8%af%86%e8%af%b4%e6%98%8e">启动参数</a>。格式为<code>&lt;启动密钥&gt;:&lt;隧道ID1&gt;,隧道ID2,隧道ID3,...</code>，其中启动密钥即上一步的访问密钥，隧道id即上一步的两个隧道id。</p><p>使用命令行安装如下：<br><code>docker run -d --name frpc-natfrp --restart=always natfrp/frpc -f &lt;启动参数&gt;</code></p><p>使用portainer-ce安装也可，值得注意的是运行时参数设置在Advanced container settings-Command &amp; logging设置，command设置为override并填入参数，如下图。<br><img src="/images/使用frp和shadowsocks实现安全访问内网服务/portainer-ce创建frpc容器设置.png" /></p><h2 id="clash根据规则分流"><a href="#clash根据规则分流" class="headerlink" title="clash根据规则分流"></a>clash根据规则分流</h2><p>我使用subconverter生成包含自定义规则的配置文件，subconverter可以自己搭建也能用别人搭好的，这里推荐一个<a href="https://acl4ssr-sub.github.io/">ACL4SSR 在线订阅转换</a>。远程配置使用自己的配置文件模板（可以参考大佬的模板），在<code>ruleset</code>和<code>proxy_group</code>对应添加节点和规则。配置完成后转换合并订阅即可。</p><h3 id="subconverter-配置文件模板"><a href="#subconverter-配置文件模板" class="headerlink" title="subconverter 配置文件模板"></a>subconverter 配置文件模板</h3><p>subconverter可以通过设置远程配置实现定制自己需要的规则分流。咱这里使用GitHub存储远程配置文件。<del>这里推荐直接复制大佬的模板，然后在此基础上修改。</del><br><img src="/images/使用frp和shadowsocks实现安全访问内网服务/ACL4SSR_Online配置文件.png" /></p><p>推荐几个基础模板：<br><a href="https://raw.githubusercontent.com/ACL4SSR/ACL4SSR/master/Clash/config/ACL4SSR_Online.ini">ACL4SSR_Online 默认版 分组比较全(与Github同步)</a><br><a href="https://raw.githubusercontent.com/ACL4SSR/ACL4SSR/master/Clash/config/ACL4SSR_Online_Full.ini">ACL4SSR_Online_Full 全分组 重度用户使用(与Github同步)</a></p><p>subconverter订阅转换设置细则可参考<a href="https://github.com/tindy2013/subconverter/blob/master/README-cn.md">官方使用文档</a>，这里只讲本教程需要的内容。</p><h4 id="Github-创建仓库"><a href="#Github-创建仓库" class="headerlink" title="Github 创建仓库"></a>Github 创建仓库</h4><p>（注册并）登录Github，创建仓库，创建远程配置文件<code>config.ini</code>。<del>这里太过简单直接跳过罢</del></p><h4 id="ruleset-设置"><a href="#ruleset-设置" class="headerlink" title="ruleset 设置"></a>ruleset 设置</h4><p>咱这里使用GitHub保存规则文件，同仓库下创建<code>ruleset.list</code>，填入要匹配的的域名或ip。具体规则在<a href="https://docs.cfw.lbyczf.com/contents/ui/profiles/rules.html">这里</a>。<br>我们这里直接填<code>DOMAIN-SUFFIX,your-domain.com</code>，将<code>your-domain.com</code>替换为你的域名，此行意为以<code>your-domain.com</code>为后缀的域名被匹配。最后保存，点击<code>Raw</code>获得真实地址。</p><p>复制大佬的配置模板，在配置模板中增加以下一行，<code>=</code>后面替换为你的proxy_group名称+规则地址。proxy_group和ruleset名称必须完全一致，否则会报错。注意，规则从上往下匹配，所以最好添加到一列ruleset的<b>最上方</b>。<br><code>ruleset=🏠 家庭内网,https://raw.githubusercontent.com/your_account/your_project/main/rulesets/ruleset.list</code></p><p>该条的含义是：从<code>ruleset.list</code>拉取规则，并将匹配到的流量使用<code>🏠 家庭内网</code>中选中的节点转发。</p><h4 id="proxy-group-设置"><a href="#proxy-group-设置" class="headerlink" title="proxy_group 设置"></a>proxy_group 设置</h4><p>在配置模板中增加以下一行，将<code>GROUPID=3</code>的<code>3</code>换成自己订阅链接/节点的序号（序号<b>从0开始计算</b>）。<br><code>custom_proxy_group=🏠 家庭内网`select`!!GROUPID=3`[]DIRECT`http://www.gstatic.com/generate_204`60,5,50</code></p><p>该条的含义是：创建一个名为<code>🏠 家庭内网</code>的代理组，使用<code>select</code>模式，添加第4条订阅和DIRECT到该节点组，延迟测速周期60秒，5秒未响应即为超时，延迟容差为50ms。</p><h4 id="获取远程配置地址"><a href="#获取远程配置地址" class="headerlink" title="获取远程配置地址"></a>获取远程配置地址</h4><p>以上两处修改完成后，GitHub创建的远程配置文件页点击<code>Raw</code>获取真实地址。</p><h3 id="Shadowsocks-节点链接生成"><a href="#Shadowsocks-节点链接生成" class="headerlink" title="Shadowsocks 节点链接生成"></a>Shadowsocks 节点链接生成</h3><p>一般使用的ss链接都经过了base64加密，我们这里先生成未加密的节点链接，再加密。</p><h4 id="获得未加密的ss链接"><a href="#获得未加密的ss链接" class="headerlink" title="获得未加密的ss链接"></a>获得未加密的ss链接</h4><p>模板：<code>method:password@hostname:port</code>。</p><p><code>method</code>是你的ss的加密方式，<code>password</code>是上面设置的密码，<code>hostname</code>和<code>port</code>是上面frp服务的地址和<b>远程</b>端口，分别替换对应内容。替换后示例<code>aes-256-gcm:barfoo@hostname:8388</code>。</p><h4 id="通过base64加密获得ss链接"><a href="#通过base64加密获得ss链接" class="headerlink" title="通过base64加密获得ss链接"></a>通过base64加密获得ss链接</h4><p>通过<a href="https://tool.chinaz.com/tools/base64.aspx">这里</a>可以便捷地实现base64加密，然后加上<code>ss://</code>大功告成，可以额外添加<code>#节点名称</code>来给自己的ss节点命名。</p><h3 id="通过-subconverter-生成全新订阅"><a href="#通过-subconverter-生成全新订阅" class="headerlink" title="通过 subconverter 生成全新订阅"></a>通过 subconverter 生成全新订阅</h3><p>使用推荐的<a href="https://acl4ssr-sub.github.io/">ACL4SSR 在线订阅转换</a>生成全新订阅。<br>在订阅链接处<b>按次序</b>填好机场订阅链接和ss链接，在订阅转换的远程配置处粘贴上面得到的远程配置地址，点生成订阅链接即可。</p><img src="/images/使用frp和shadowsocks实现安全访问内网服务/subconverter生成订阅.png"/><h2 id="DNS-服务器设置"><a href="#DNS-服务器设置" class="headerlink" title="DNS 服务器设置"></a>DNS 服务器设置</h2><p>这里使用ADGuard Home做DNS服务，ADGuard Home的DNS重写可以看作自定义hosts功能。选择过滤器-DNS重写，添加DNS重写，ip为反向代理服务器的ip。ADGuard Home这里支持泛域名，好评！<br><img src="/images/使用frp和shadowsocks实现安全访问内网服务/DNS重写.png" /></p><p>这样所有对该域名的DNS请求都会将目标指向反向代理服务器所在ip，DNS设置完毕。</p><h2 id="内网流量转发设置"><a href="#内网流量转发设置" class="headerlink" title="内网流量转发设置"></a>内网流量转发设置</h2><p>现在，你已经可以实现外网访问本地内网服务了。但内网设备clash也会绕这么大一圈来访问内网服务，这不符合我们的初衷。这就需要我们对内网流量转发做额外设置，<del>假装在这个过程中访问了frp服务器并成功转发流量</del>。</p><h3 id="DNS-服务器设置-1"><a href="#DNS-服务器设置-1" class="headerlink" title="DNS 服务器设置"></a>DNS 服务器设置</h3><p>梅开二度，我们又回到了DNS重写，添加域名为frp服务器的域名，ip为反代服务器的ip。</p><h3 id="反代设置-Streams-流量转发"><a href="#反代设置-Streams-流量转发" class="headerlink" title="反代设置 Streams 流量转发"></a>反代设置 Streams 流量转发</h3><p>这里通过Nginx Proxy Manager设置，没有搭建的同学可以查看咱之前的搭建教程：<a href="https://sunjx97.github.io/2022/01/01/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAnginx-proxy-manager%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8CSSL%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/">《使用docker搭建nginx proxy manager实现反向代理和SSL证书申请》</a>。</p><p>Nginx的Stream模块工作在第四层，我们可以用来转发tcp、udp数据包。登录管理页面，点击Streams-Add Stream，<code>Incoming Port</code>填frp隧道的<b>远程端口</b>，<code>Forward Host</code>填ss服务端的ip，<code>Forward Port</code>填ss服务端的端口（即上面设置的<code>9000</code>）。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此，本教程终于结束了。对于内外网两栖的设备在节点组需要选择自己的ss节点，而内网设备直接选择DIRECT即可，DNS和反代服务器会将流量转发到正确的服务ip和端口。相对于<code>@靛青K</code>大佬直接使用ddns和公网ip搭建ss服务端，这个方法肯定麻烦许多，但对于当前ipv6未全面铺开的情况和大内网的我来说，终归是够用了。<del>所以ipv6时代什么时候来啊(#`O′)/</del></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/read/cv9219407">使用 Shadowsocks 访问家庭内网</a><br><a href="https://doc.natfrp.com/#/frpc/usage/docker">使用 docker 管理 frpc 运行 - SAKURA FRP</a><br><a href="https://github.com/tindy2013/subconverter/blob/master/README-cn.md">subconverter 官方使用文档</a><br><a href="https://docs.cfw.lbyczf.com/contents/ui/profiles/rules.html">规则编辑 - Clash for Windows</a><br><a href="https://blog.kelu.org/tech/2017/04/25/generate-shadowsocks-qrcode.html">shadowsocks 生成二维码 URI</a><br><a href="https://yjdwbj.github.io/2020/02/12/%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%A4%96VPS%E6%8C%87%E5%8D%97-Linode/#URI%E4%B8%8E%E4%BA%8C%E7%BB%B4%E7%A0%81">URI与二维码 - shadowsocks-libev</a></p>]]></content>
    
    
    <summary type="html">初期自建服务器进度完成后，第二步便是实现外网对内网服务的访问（不然岂不是太过鸡肋w)。但苦于没有公网ip，传统内网穿透（如frp）把自身服务公开到公网又觉得太不安全，zerotier虚拟局域网又要频繁切换vpn很不方便，总是找不到个万全的方法，因而一直处于搁置状态。如今看到b站 @靛青K 大佬通过ss实现内网服务安全访问的方法，咱灵光一闪，想到通过frp解决没有公网ip问题，进而通过ss实现内网安全访问的思路，于是便有了这篇文章——</summary>
    
    
    
    <category term="selfhosted" scheme="https://sunjx97.github.io/categories/selfhosted/"/>
    
    
    <category term="内网穿透" scheme="https://sunjx97.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
    <category term="frp" scheme="https://sunjx97.github.io/tags/frp/"/>
    
    <category term="Shadowsocks" scheme="https://sunjx97.github.io/tags/Shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>解决transmission使用网络共享的监控目录时的监控失灵问题</title>
    <link href="https://sunjx97.github.io/2022/01/07/%E8%A7%A3%E5%86%B3transmission%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E5%85%B1%E4%BA%AB%E7%9A%84%E7%9B%91%E6%8E%A7%E7%9B%AE%E5%BD%95%E6%97%B6%E7%9A%84%E7%9B%91%E6%8E%A7%E5%A4%B1%E7%81%B5%E9%97%AE%E9%A2%98/"/>
    <id>https://sunjx97.github.io/2022/01/07/%E8%A7%A3%E5%86%B3transmission%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E5%85%B1%E4%BA%AB%E7%9A%84%E7%9B%91%E6%8E%A7%E7%9B%AE%E5%BD%95%E6%97%B6%E7%9A%84%E7%9B%91%E6%8E%A7%E5%A4%B1%E7%81%B5%E9%97%AE%E9%A2%98/</id>
    <published>2022-01-07T15:11:08.000Z</published>
    <updated>2022-02-12T13:10:25.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>transmission可以通过设置watch监控文件夹来自动添加监控目录内的种子，但如果监控文件夹是smb共享，则会出现失灵的现象（即只在开启或重启时添加一次目录内的种子）。本人使用NAS集中管理自己的数据，docker版transmission也是映射的主机挂载的smb共享文件夹，便出现了日常使用不自动添加种子的问题。</p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>transmission在Linux下默认使用inotify监控监控目录，而inotify不对cifs共享有效。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在配置文件目录的settings.json加入下行即可。</p><figure class="highlight json"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;watch-dir-force-generic&quot;</span>: <span class="hljs-literal">true</span>,<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://forum.transmissionbt.com/viewtopic.php?t=17960">Watch-dir on network folder</a></p>]]></content>
    
    
    <summary type="html">Linux下使用transmission时，其监控文件夹功能会在监控smb共享文件夹时失效。</summary>
    
    
    
    <category term="selfhosted" scheme="https://sunjx97.github.io/categories/selfhosted/"/>
    
    
    <category term="transmission" scheme="https://sunjx97.github.io/tags/transmission/"/>
    
    <category term="pt" scheme="https://sunjx97.github.io/tags/pt/"/>
    
    <category term="smb" scheme="https://sunjx97.github.io/tags/smb/"/>
    
  </entry>
  
  <entry>
    <title>解决通过fstab开机挂载smb文件夹导致的Database is locked问题</title>
    <link href="https://sunjx97.github.io/2022/01/04/%E8%A7%A3%E5%86%B3%E9%80%9A%E8%BF%87fstab%E5%BC%80%E6%9C%BA%E6%8C%82%E8%BD%BDsmb%E6%96%87%E4%BB%B6%E5%A4%B9%E5%AF%BC%E8%87%B4%E7%9A%84Database-is-locked%E9%97%AE%E9%A2%98/"/>
    <id>https://sunjx97.github.io/2022/01/04/%E8%A7%A3%E5%86%B3%E9%80%9A%E8%BF%87fstab%E5%BC%80%E6%9C%BA%E6%8C%82%E8%BD%BDsmb%E6%96%87%E4%BB%B6%E5%A4%B9%E5%AF%BC%E8%87%B4%E7%9A%84Database-is-locked%E9%97%AE%E9%A2%98/</id>
    <published>2022-01-04T05:38:54.000Z</published>
    <updated>2022-02-12T13:10:35.306Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>发现在使用fstab开机挂载的smb文件夹会有Database is locked的问题，如通过docker安装的nginx-proxy-manager和qiandao，映射的文件夹是smb（cifs）共享挂载的，因为默认使用了sqlite的数据库，会导致Database is locked问题，如下图：</p><img src="/images/解决通过fstab开机挂载smb文件夹导致的Database-is-locked问题/sqlite报错 01.png" width="70%" /><img src="/images/解决通过fstab开机挂载smb文件夹导致的Database-is-locked问题/sqlite报错 02.png" /><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在挂载时加入<b>nolock</b>参数即可。</p><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//my</span>server /mymount cifs username=**,password=**,nolock,uid=<span class="hljs-number">1000</span>,gid=<span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.archiware.com/blog/pure_forum/pure-question-answers/database-is-locked/">Database is locked</a></p>]]></content>
    
    
    <summary type="html">发现在使用fstab开机挂载时，使用sqlite的数据库，有时会导致Database is locked问题，这时需要通过添加参数来解决。</summary>
    
    
    
    <category term="selfhosted" scheme="https://sunjx97.github.io/categories/selfhosted/"/>
    
    
    <category term="sqlite" scheme="https://sunjx97.github.io/tags/sqlite/"/>
    
    <category term="docker" scheme="https://sunjx97.github.io/tags/docker/"/>
    
    <category term="smb" scheme="https://sunjx97.github.io/tags/smb/"/>
    
  </entry>
  
  <entry>
    <title>蜗牛星际A款机箱的六盘位改造</title>
    <link href="https://sunjx97.github.io/2022/01/01/%E8%9C%97%E7%89%9B%E6%98%9F%E9%99%85A%E6%AC%BE%E6%9C%BA%E7%AE%B1%E7%9A%84%E5%85%AD%E7%9B%98%E4%BD%8D%E6%94%B9%E9%80%A0/"/>
    <id>https://sunjx97.github.io/2022/01/01/%E8%9C%97%E7%89%9B%E6%98%9F%E9%99%85A%E6%AC%BE%E6%9C%BA%E7%AE%B1%E7%9A%84%E5%85%AD%E7%9B%98%E4%BD%8D%E6%94%B9%E9%80%A0/</id>
    <published>2022-01-01T12:46:11.000Z</published>
    <updated>2022-02-12T13:10:46.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>距离改造已经过去很久了，直到现在才发出来_(:3」∠)_</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>因为蜗牛星际A款机箱本来就带一个2.5寸硬盘位（机箱内部），所以只要再扩展出一个2.5寸硬盘位即可。</p><p>用到了一个2.5寸硬盘支架，购买链接在<a href="https://item.taobao.com/item.htm?id=605572434546">这里</a>，购买半高PCIe款。</p><p>使用的螺丝购买链接在<a href="https://detail.tmall.com/item.htm?id=606010296755">这里</a>，<b>规格为M3</b>，建议买短点。</p><ol><li><p>先用四个螺丝将支架和硬盘固定（硬盘有一面有四个螺丝孔），我这边买的螺丝比较长，所以用螺母当垫片使用。</p><img src="/images/蜗牛星际A款机箱的六盘位改造/增加2.5寸盘位 01.jpg" /></li><li><p>因为螺丝本身有厚度，所以支架最底下那个盘位要空出来，直接在第二个盘位安装2.5寸硬盘即可。</p><img src="/images/蜗牛星际A款机箱的六盘位改造/增加2.5寸盘位 02.jpg" /><img src="/images/蜗牛星际A款机箱的六盘位改造/增加2.5寸盘位 03.jpg" /></li></ol><p>成品如图：<br><img src="/images/蜗牛星际A款机箱的六盘位改造/增加2.5寸盘位 04.jpg" /><br><img src="/images/蜗牛星际A款机箱的六盘位改造/增加2.5寸盘位 05.jpg" /></p><p>大概只能扩充到2个2.5寸盘位，毕竟离机箱壁太近了。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>机箱内部的2.5寸盘位因为要将4个螺丝孔那面对外，所以<b>对硬盘厚度有要求</b>，建议厚盘装在外面。</p>]]></content>
    
    
    <summary type="html">蜗牛星际A款机箱改造6盘位（4个3.5寸盘位+2个2.5寸盘位）</summary>
    
    
    
    <category term="DIY" scheme="https://sunjx97.github.io/categories/DIY/"/>
    
    
    <category term="蜗牛星际" scheme="https://sunjx97.github.io/tags/%E8%9C%97%E7%89%9B%E6%98%9F%E9%99%85/"/>
    
    <category term="DIY" scheme="https://sunjx97.github.io/tags/DIY/"/>
    
  </entry>
  
  <entry>
    <title>使用docker搭建nginx proxy manager实现反向代理和SSL证书申请</title>
    <link href="https://sunjx97.github.io/2022/01/01/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAnginx-proxy-manager%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8CSSL%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/"/>
    <id>https://sunjx97.github.io/2022/01/01/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAnginx-proxy-manager%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8CSSL%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/</id>
    <published>2022-01-01T03:12:37.000Z</published>
    <updated>2022-02-16T11:55:42.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自从入坑NAS以来，（黑）群晖一直都是我文件存储管理的得力助手。但随着我的<del>圈内吹水日益熟练</del>学习和理解不断加深，黑裙已不能满足我的需求。如今，是时候告别（黑）群晖，往更专业的自建服务器方向发展了。其中关键的一步，便是找到能方便替换群晖反向代理服务的开源项目，而nginx proxy manager给了我一个很好的选择。</p><h2 id="nginx-proxy-manager介绍"><a href="#nginx-proxy-manager介绍" class="headerlink" title="nginx proxy manager介绍"></a>nginx proxy manager介绍</h2><p>nginx proxy manager能让我们轻松地转发到在家里或其他地方运行的网站，包括免费的SSL，而不需要对Nginx或Letsencrypt了解太多。便捷直观的web页面管理和操作无疑大大简化了一般nginx反代服务的步骤。</p><h2 id="docker安装nginx-proxy-manager"><a href="#docker安装nginx-proxy-manager" class="headerlink" title="docker安装nginx proxy manager"></a>docker安装nginx proxy manager</h2><p>推荐使用docker-compose安装</p><figure class="highlight yaml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">app:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">&#x27;jc21/nginx-proxy-manager:latest&#x27;</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-comment"># These ports are in format &lt;host-port&gt;:&lt;container-port&gt;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;80:80&#x27;</span> <span class="hljs-comment"># Public HTTP Port</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;443:443&#x27;</span> <span class="hljs-comment"># Public HTTPS Port</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;81:81&#x27;</span> <span class="hljs-comment"># Admin Web Port</span><br>      <span class="hljs-comment"># Add any other Stream port you want to expose</span><br>      <span class="hljs-comment"># - &#x27;21:21&#x27; # FTP</span><br><br>    <span class="hljs-comment"># Uncomment the next line if you uncomment anything in the section</span><br>    <span class="hljs-comment"># environment:</span><br>      <span class="hljs-comment"># Uncomment this if you want to change the location of </span><br>      <span class="hljs-comment"># the SQLite DB file within the container</span><br>      <span class="hljs-comment"># DB_SQLITE_FILE: &quot;/data/database.sqlite&quot;</span><br><br>      <span class="hljs-comment"># Uncomment this if IPv6 is not enabled on your host</span><br>      <span class="hljs-comment"># DISABLE_IPV6: &#x27;true&#x27;</span><br><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./data:/data</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./letsencrypt:/etc/letsencrypt</span><br></code></pre></td></tr></table></figure><p>浏览器输入【docker主机ip:81】，成功进入web页面，初次登录使用邮箱：<a href="mailto:&#x61;&#x64;&#x6d;&#x69;&#110;&#x40;&#101;&#120;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#99;&#x6f;&#x6d;">&#x61;&#x64;&#x6d;&#x69;&#110;&#x40;&#101;&#120;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#99;&#x6f;&#x6d;</a>，密码：changeme。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/通过docker安装nginx proxy manager 01.png" /></p><p>登录进去后会让你设置管理员的用户名（Full Name），昵称（Nickname）和邮箱。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/通过docker安装nginx proxy manager 02.png" width="60%" /></p><p>接下来设置密码，旧密码即预设密码changeme。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/通过docker安装nginx proxy manager 03.png" width="60%" /></p><p>至此，nginx proxy manager初始化完成。</p><h2 id="使用nginx-proxy-manager实现反向代理"><a href="#使用nginx-proxy-manager实现反向代理" class="headerlink" title="使用nginx proxy manager实现反向代理"></a>使用nginx proxy manager实现反向代理</h2><p>登录进入主面版，点击Proxy Hosts转到反向代理设置界面。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/nginx proxy manager反向代理 01.png" /></p><p>点击Add Proxy Host，添加一个反向代理。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/nginx proxy manager反向代理 02.png" /></p><p>在Details页面，Domain Names填写你的域名，Scheme填写反代对象的协议（http/https），Forward Hostname/IP填写反代对象的地址，Forward Port填写反代对象的端口号。</p><p><code>Domain Names</code> - 填写需要反代的域名<br><code>Scheme</code> - 选择来源的协议<br><code>Forward Hostname / IP</code> - 填写来源的主机名或IP<br><code>Forward Port</code> - 填写来源的端口<br><code>Cache Assets</code> - 是否启用缓存<br><code>Block Common Expoits</code> - 阻止常见的漏洞<br><code>Websockets Support</code> - 是支援 Websockets<br><code>Access List</code> - 权限列表选择，可以给反代的网页设置账户密码，验证通过后才能正常打开</p><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/nginx proxy manager反向代理 03.png" width="60%" /><p>如果有https加密需求，转到SSL页面，将SSL Certificate选择为你申请的证书，建议勾选SSL Force（强制SSL）。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/nginx proxy manager反向代理 04.png" width="60%" /></p><p>点击保存，在反向代理页面可以看到刚刚设置的反向代理。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/nginx proxy manager反向代理 05.png" /></p><p>测试相应网站，反代成功。</p><h2 id="SSL证书申请"><a href="#SSL证书申请" class="headerlink" title="SSL证书申请"></a>SSL证书申请</h2><h3 id="HTTP-01-验证方式"><a href="#HTTP-01-验证方式" class="headerlink" title="HTTP-01 验证方式"></a>HTTP-01 验证方式</h3><p>最简单常规的SSL证书申请方式，如果你的主机可以放行80端口（如在各大公有云处购买的主机），推荐使用这种方式。<del>我这边没有虚拟主机，家用80端口也被封锁了，所以也没用过这种方式，姑且放在这里给大家参考_(:3」∠)_</del></p><p>转到反代编辑页面，在SSL页面选择Request a new SSL Certificate，建议勾选SSL Force（强制SSL），打开勾选I Agree to the Let’s Encrypt Terms of Service同意Let’s Encrypt相关条款，点击保存。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/nginx proxy manager设置SSL证书 HTTP-01.png" width="60%" /></p><p>可以看到反代已自动申请SSL证书，可以通过https访问了。证书有效期3个月，到期会自动续期。</p><h3 id="DNS-01-验证方式"><a href="#DNS-01-验证方式" class="headerlink" title="DNS-01 验证方式"></a>DNS-01 验证方式</h3><p>因为国内ISP一般都封锁了80端口，所以HTTP-01验证方式大概率在家庭自建服务器的情况下不会成功。作为替代，我们可以选择使用DNS-01的验证方式来申请SSL证书。相较于HTTP-01，DNS-01可以申请<a href="https://letsencrypt.org/zh-cn/docs/challenge-types/">支持通配符的域名证书</a>，也算弥补了其操作繁琐的缺点。这里以DNSPOD和CloudFlare为例：</p><h4 id="·-DNSPOD"><a href="#·-DNSPOD" class="headerlink" title="· DNSPOD"></a>· DNSPOD</h4><h5 id="1-申请api-key"><a href="#1-申请api-key" class="headerlink" title="1. 申请api key"></a>1. 申请api key</h5><p>首先登录DNSPOD控制台，在右上角找到 API密钥 项。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/DNSPOD API申请 01.png" width="50%" /></p><p>转到 DNSPod Token 页面，点击创建密钥。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/DNSPOD API申请 02.png" width="60%" /></p><p>设置密钥名称<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/DNSPOD API申请 03.png" width="60%" /></p><p>查看并保存ID和Token项，这里的内容<b>只会显示一次</b>，一定要保存好。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/DNSPOD API申请 04.png" width="60%" /></p><p>已经能在总览看到相关API已申请成功。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/DNSPOD API申请 05.png" /></p><h5 id="2-配置nginx-proxy-manager并申请SSL证书"><a href="#2-配置nginx-proxy-manager并申请SSL证书" class="headerlink" title="2. 配置nginx proxy manager并申请SSL证书"></a>2. 配置nginx proxy manager并申请SSL证书</h5><p>点击SSL Certificates，转到SSL Certificates页面；再点击右上角Add SSL Certificate，选择Let’s Encrypt。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/nginx proxy manager设置SSL证书 DNS-01 01.png" /></p><p>如下图，Domain names填写自己的域名，Email Address for Let’s Encrypt填写自己的邮箱。</p><p>打开Use a DNS Challenge，DNS Provider选择DNSPod，将dns_dnspod_email中的<a href="mailto:&#101;&#x6d;&#97;&#x69;&#108;&#x40;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#101;&#x2e;&#x63;&#111;&#x6d;">&#101;&#x6d;&#97;&#x69;&#108;&#x40;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#101;&#x2e;&#x63;&#111;&#x6d;</a>替换为DNSPod的邮箱，dns_dnspod_api_token中的id,key对应填入（即在上一步申请得到的id和token），注意不要删掉英文双引号，且id与token用英文逗号连接。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">dns_dnspod_email</span> = <span class="hljs-string">&quot;email@example.com&quot;</span><br><span class="hljs-attr">dns_dnspod_api_token</span> = <span class="hljs-string">&quot;id,key&quot;</span><br></code></pre></td></tr></table></figure><p>勾选I Agree to the Let’s Encrypt Terms of Service同意Let’s Encrypt相关条款，点击保存。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/nginx proxy manager设置SSL证书 DNS-01 02.png" /></p><p>可以看到SSL证书已经申请完成，有效期3个月，到期会自动续期。<br><img src="/images/使用docker搭建nginx-proxy-manager实现反向代理和SSL证书申请/nginx proxy manager设置SSL证书 DNS-01 03.png" /></p><h4 id="·-CloudFlare"><a href="#·-CloudFlare" class="headerlink" title="· CloudFlare"></a>· CloudFlare</h4><h5 id="1-获取api-key"><a href="#1-获取api-key" class="headerlink" title="1. 获取api key"></a>1. 获取api key</h5><p>打开<a href="https://dash.cloudflare.com/profile/api-tokens">个人资料-API令牌</a>，找到<b>API 密钥</b>，查看并复制<b>Global API Key</b>。</p><h5 id="2-配置nginx-proxy-manager并申请SSL证书-1"><a href="#2-配置nginx-proxy-manager并申请SSL证书-1" class="headerlink" title="2. 配置nginx proxy manager并申请SSL证书"></a>2. 配置nginx proxy manager并申请SSL证书</h5><p>同上，不过要将申请信息进行替换（初始的只有api token的形式申请会有问题）。<a href="mailto:&#x73;&#x6f;&#x6d;&#x65;&#116;&#x68;&#105;&#x6e;&#x67;&#x40;&#104;&#x6f;&#116;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;">&#x73;&#x6f;&#x6d;&#x65;&#116;&#x68;&#105;&#x6e;&#x67;&#x40;&#104;&#x6f;&#116;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;</a>替换为cloudflare的邮箱，0123456789abcdef0123456789abcdef01234567替换为上面得到的Global API Key。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># Cloudflare API token</span><br><span class="hljs-attr">dns_cloudflare_email</span> = something@hotmail.com<br><span class="hljs-attr">dns_cloudflare_api_key</span> = <span class="hljs-number">0123456789</span>abcdef0123456789abcdef01234567<br></code></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="需要开启Websockets-Support的应用-网站"><a href="#需要开启Websockets-Support的应用-网站" class="headerlink" title="需要开启Websockets Support的应用/网站"></a>需要开启Websockets Support的应用/网站</h3><p>Proxmox VE：不开启会导致novnc连接错误<br>jlesage/jdownloader-2：不开启会无法进入webui管理页面<br>truenas：不开启会导致webui无法登录</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://nginxproxymanager.com/guide/#project-goal">Nginx Proxy Manager</a><br><a href="https://letsencrypt.org/zh-cn/docs/challenge-types/">验证方式 - Let’s Encrypt</a><br><a href="https://www.bilibili.com/video/BV1Gg411w7kQ">【Docker系列】一个反向代理神器——Nginx Proxy Manager</a><br><a href="https://blog.laoda.de/archives/nginxproxymanager">【Docker系列】一个反向代理神器——Nginx Proxy Manager</a><br><a href="https://www.jianshu.com/p/659dc904967f">certbot dns插件</a><br><a href="https://github.com/NginxProxyManager/nginx-proxy-manager/issues/680#issuecomment-722016183">Cannot get Let’s Encrypt cert via cloudflare dns challange</a><br><a href="https://www.sio.moe/2021/12/18/computer/Docker-Container/Use-Docker-to-install-Nginx-ProxyManager-for-SSL-reverse-proxy/">使用Docker安裝Nginx-ProxyManager進行SSL反向代理</a></p>]]></content>
    
    
    <summary type="html">自从入坑NAS以来，（黑）群晖一直都是我文件存储管理的得力助手。但随着我的学习和理解不断加深，黑裙已不能满足我的需求。如今，是时候告别（黑）群晖，往更专业的自建服务器方向发展了。其中关键的一步，便是找到能方便替换群晖反向代理服务的开源项目，而nginx proxy manager给了我一个很好的选择。</summary>
    
    
    
    <category term="selfhosted" scheme="https://sunjx97.github.io/categories/selfhosted/"/>
    
    
    <category term="反向代理" scheme="https://sunjx97.github.io/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
    <category term="SSL" scheme="https://sunjx97.github.io/tags/SSL/"/>
    
  </entry>
  
  <entry>
    <title>Transmission 2.94升级3.00 跳过启动校验</title>
    <link href="https://sunjx97.github.io/2021/12/18/Transmission-2-94%E5%8D%87%E7%BA%A73-00-%E8%B7%B3%E8%BF%87%E5%90%AF%E5%8A%A8%E6%A0%A1%E9%AA%8C/"/>
    <id>https://sunjx97.github.io/2021/12/18/Transmission-2-94%E5%8D%87%E7%BA%A73-00-%E8%B7%B3%E8%BF%87%E5%90%AF%E5%8A%A8%E6%A0%A1%E9%AA%8C/</id>
    <published>2021-12-18T12:13:22.000Z</published>
    <updated>2022-02-12T13:10:55.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>将transmission升级到了3.00，发现每次启动都会对升级前的旧种子重新校验，然后就是数十个小时的校验过程，实在让人头大。经过多次尝试，终于找到可以跳过启动校验（只校验一次）的方法了，现记录如下。</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>transmission在3.00使用<b>40位hash</b>记录种子文件的信息（之前是16位），在torrents和resume文件夹中新生成的文件都是用40位hash值命名的。要解决每次启动都重复校验的问题，需要将旧种子的信息更新。主要有以下几步：</p><ol><li>等待transmission第一次校验完生成<b>新的40位hash命名的resume文件</b>并将旧种子的的resume文件删除</li><li>将对应的旧种子的torrent文件更名为<b>相同的40位hash</b>。</li></ol><h3 id="1-等待初次校验完成"><a href="#1-等待初次校验完成" class="headerlink" title="1. 等待初次校验完成"></a>1. 等待初次校验完成</h3><!-- ![](/images/resume新旧文件对比.png) --><img src="/images/Transmission-2-94升级3-00-跳过启动校验/resume新旧文件对比.png" width="70%" />等待校验完成并删除旧resume文件（很好分辨，2.94版本是【种子名+前16位hash】的命名方式，而3.0版本生成的新resume文件都是【40位hash】命名方式）<h3 id="2-对旧torrent文件重命名"><a href="#2-对旧torrent文件重命名" class="headerlink" title="2. 对旧torrent文件重命名"></a>2. 对旧torrent文件重命名</h3><p>停止docker中的transmission服务，将旧torrent文件重命名为新40位hash形式。<br>因为旧torrent文件名称包含前16位hash，所以可以直接将16位hash字符串与resume文件夹内所有文件进行匹配，如果匹配上前16位，则修正命名。</p><p>写了段<a href="https://github.com/sunjx97/torrent-file-rename">代码</a>解决命名问题：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> re<br><br>torrents_src = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入torrents文件夹绝对路径：&#x27;</span>)<br>resume_src = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入resume文件夹绝对路径：&#x27;</span>)<br><br>torrent_list = os.listdir(torrents_src)<br>resume_list = os.listdir(resume_src)<br><br>count = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> torrent <span class="hljs-keyword">in</span> torrent_list:<br>    <span class="hljs-comment"># 从16位hash值开始，到后缀名结束</span><br>    <span class="hljs-comment"># 如果是新版文件40位hash，则会截取后16位，在下面match起始位置匹配匹配失败</span><br>    pattern = torrent[-<span class="hljs-number">24</span>:-<span class="hljs-number">8</span>]<br><br>    <span class="hljs-keyword">for</span> resume <span class="hljs-keyword">in</span> resume_list:<br>        <span class="hljs-keyword">if</span> re.match(pattern, resume[:-<span class="hljs-number">7</span>], re.I):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Ok, find the files!&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;torrent:&#x27;</span>, torrent)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;resume:&#x27;</span>, resume)<br>            os.rename(torrents_src+<span class="hljs-string">&#x27;\\&#x27;</span>+torrent, torrents_src+<span class="hljs-string">&#x27;\\&#x27;</span>+resume[:-<span class="hljs-number">7</span>]+<span class="hljs-string">&#x27;.torrent&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;torrent&#125;</span> 已更名为 <span class="hljs-subst">&#123;resume[:-<span class="hljs-number">7</span>]&#125;</span>.torrent&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;==========================&#x27;</span>)<br>            count += <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;已成功命名<span class="hljs-subst">&#123;count&#125;</span>个种子文件&#x27;</span>)<br></code></pre></td></tr></table></figure><p>运行结果如下，一切顺利。<br><img src="/images/Transmission-2-94升级3-00-跳过启动校验/torrent更名成功.png" /></p><p>启动transmission，可以看到已经没有在校验了。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>在操作前<b>备份</b>好torrents和resume文件夹</li><li>初次校验完成后建议<b>停止</b>transmission服务后再操作。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/ylxb2016/PT-help/blob/master/PT%20Tutorial/%E3%80%90%E5%8E%9F%E5%88%9B%E3%80%91Transmission%20%E6%89%8B%E5%8A%A8%E8%B7%B3%E8%BF%87%E6%A0%A1%E9%AA%8C%20%E6%95%99%E7%A8%8B.md">【原创】Transmission 手动跳过校验 教程.md</a><br><a href="https://forum.transmissionbt.com/viewtopic.php?f=2&t=20838&p=80079&hilit=resume&sid=6a23eb2473eab4b32c5df60332c16ae1">Move a half downloaded file from Android to Windows/Linux</a><br><a href="https://forum.transmissionbt.com/viewtopic.php?f=2&t=20694&p=79636&hilit=resume&sid=6a23eb2473eab4b32c5df60332c16ae1#p79636">Reinstall Transmission and moving data to avoid torrent recheck</a></p>]]></content>
    
    
    <summary type="html">将transmission升级到了3.00，发现每次启动都会对升级前的旧种子重新校验，然后就是数十个小时的校验过程，实在让人头大。经过多次尝试，终于找到可以跳过启动校验（只校验一次）的方法了，现记录如下。</summary>
    
    
    
    <category term="pt" scheme="https://sunjx97.github.io/categories/pt/"/>
    
    
    <category term="transmission" scheme="https://sunjx97.github.io/tags/transmission/"/>
    
    <category term="pt" scheme="https://sunjx97.github.io/tags/pt/"/>
    
  </entry>
  
</feed>
