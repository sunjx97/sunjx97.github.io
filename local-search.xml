<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ipv6 环境下的家庭网络维护</title>
    <link href="/posts/266c2cf6/"/>
    <url>/posts/266c2cf6/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>千呼万唤始出来，ipv6 终于在我这边落地了。正好赶上周末，就折腾了一下家中相关的网络配置，顺便加以记录。</p><h2 id="路由器开启-ipv6"><a href="#路由器开启-ipv6" class="headerlink" title="路由器开启 ipv6"></a>路由器开启 ipv6</h2><h3 id="关于-IPv6"><a href="#关于-IPv6" class="headerlink" title="关于 IPv6"></a>关于 IPv6</h3><p>通常情况下，客户端会同时存在多个 IPv6 地址，一般包括：</p><ul><li>Loopback 地址：<code>::1</code>，等价于 IPv4 中的 <code>127.0.0.1</code>。</li><li>链路本地地址（Link Local Address）：<code>fe80::/10</code> 网段，只在区域中是合法地址，类似于 IPv4 中的 <code>169.254.0.0/16</code>。不可路由，电脑自动生成。</li><li>唯一区域地址（Unique Local Addresses, ULA）：私有地址空间，只能用于本地通信，不可在公网路由，但支持跨子网的内网通信。和 IPv4 的专用网络地址 <code>10.0.0.0/8</code>、<code>172.16.0.0/12</code> 和 <code>192.168.0.0/16</code> 类似，在 RFC 4193 中定义。固定前缀是 <code>fc00::/7</code>，分为 <code>fc00::/8</code> 和 <code>fd00::/8</code> 两部分，<code>fc00::/8</code> 目前作为保留地址没有定义，<code>fd00::/8</code> 是现在使用的 ULA 地址，其中 40bit 随机生成以避免冲突，可以使用 <a href="https://cd34.com/rfc4193/">ULA 生成工具</a> 来生成。</li><li>全局地址（Global Address Type）：通常意义上的公网地址，<code>2001::/16</code>。但 <code>2002:</code> 开头的是特殊的 6to4 过渡地址，不是原生的纯 IPv6 网路地址。<ul><li>电信 <code>240e</code> 开头</li><li>联通 <code>2408</code> 开头</li><li>移动 <code>2409</code> 开头</li></ul></li><li><del>本地站点地址（Site Local Address）：<code>fec0::/10</code> 网段，私网地址，目前在 RFC 规范中已被废弃。</del></li></ul><p>此外，考虑到安全等因素，客户端会同时存在多个公网 IP 地址，一个是 SLAAC 产生的地址，基于 EUI-64 标准和网卡生成，不作为首选通信地址，即下方的 IPv6 地址；另一个是 SLAAC 产生的临时地址，用于网络通信，暴露于公网，有效期较短，用于保护隐私，即下方的临时 IPv6 地址。</p><h3 id="ipv6-的发放模式"><a href="#ipv6-的发放模式" class="headerlink" title="ipv6 的发放模式"></a>ipv6 的发放模式</h3><p>ipv6 有三种分配模式：</p><ul><li>SLAAC</li><li>Stateful DHCPv6</li><li>Stateless DHCPv6</li></ul><p>因为是租房，光猫不在我控制范围内，分配到我路由器时已经是 <code>/64</code> 的地址了（悲），所以我这里使用 SLAAC 模式让<strong>光猫</strong>给下游设备分配 ipv6，根据 mac 随机生成后缀也相对更安全。</p><p>在我的 Openwrt 固件的图形管理页面有些配置没有，所以使用 ssh 远程到路由器，修改配置文件 <code>/etc/config/dhcp</code> 并重启。<br>这里要将 <code>lan</code> 和 <code>wan6</code> 的 <code>ra</code>、<code>dhcpv6</code>、<code>ndp</code> 三项指定为 <code>&#39;relay&#39;</code>，即将路由器配置为<strong>中继模式</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs conf">config dhcp &#x27;lan&#x27;<br>        option interface &#x27;lan&#x27;<br>        option start &#x27;100&#x27;<br>        option limit &#x27;150&#x27;<br>        option leasetime &#x27;12h&#x27;<br>        option dhcpv4 &#x27;server&#x27;<br>        option force &#x27;1&#x27;<br>        option ra &#x27;relay&#x27;<br>        option dhcpv6 &#x27;relay&#x27;<br>        option ndp &#x27;relay&#x27;<br><br>config dhcp &#x27;wan&#x27;<br>        option interface &#x27;wan&#x27;<br>        option ignore &#x27;1&#x27;<br><br>config dhcp &#x27;wan6&#x27;<br>        option interface &#x27;wan6&#x27;<br>        option ignore &#x27;1&#x27;<br>        option master &#x27;1&#x27;<br>        option ra &#x27;relay&#x27;<br>        option dhcpv6 &#x27;relay&#x27;<br>        option ndp &#x27;relay&#x27;<br></code></pre></td></tr></table></figure><h3 id="ADGuard-home-配置"><a href="#ADGuard-home-配置" class="headerlink" title="ADGuard home 配置"></a>ADGuard home 配置</h3><p>我开启 ipv6 主要是为了在 bt&#x2F;pt 时能获得更好的连接性，以及能在外访问家中的服务。当下 ipv6 建设并不完善，ipv6 优先的话有时会导致网速变慢和部分网页组件无法加载等问题，<del>且 clash 对 ipv6 的支持并不好，</del>所以我还是只使用 ipv4 的 dns 服务。</p><p>通过 设置 - DNS 设置 - DNS 服务配置 项，我们可以关闭 ipv6 地址解析。<br>勾选<strong>禁用 IPv6 地址的解析</strong>即可。</p><img src="/images/ipv6 环境下的家庭网络维护/禁用 ipv6 的 dns 解析.png" /><h2 id="docker-容器开启-ipv6"><a href="#docker-容器开启-ipv6" class="headerlink" title="docker 容器开启 ipv6"></a>docker 容器开启 ipv6</h2><p>相较于 docker 默认的 bridge 网络模式，macvlan 可以控制创建容器时的 ip 地址，方便我们针对 ip 地址进行更精细的操作。我们可以在 docker 中创建 macvlan 网络时添加参数，使之默认支持 ipv6。<br>注：下文提及的所有 docker 容器均使用 macvlan 网络，且获得了独立的公网 ipv6 地址。</p><h3 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h3><h4 id="查看宿主机网卡名称"><a href="#查看宿主机网卡名称" class="headerlink" title="查看宿主机网卡名称"></a>查看宿主机网卡名称</h4><p>打开安装 docker 的宿主机，先查询网卡&#x2F;接口名称。<br>执行以下命令：<code>ifconfig</code>，结合 ip 地址，可以看到我这里的网卡名为 <code>ens18</code>。</p><img src="/images/ipv6 环境下的家庭网络维护/查看宿主机网卡名称.png" width="75%" /><h4 id="创建-macvlan-网络"><a href="#创建-macvlan-网络" class="headerlink" title="创建 macvlan 网络"></a>创建 macvlan 网络</h4><p>执行以下命令创建 macvlan 网络：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network create -d macvlan \<br>--subnet=192.168.1.0/24 \<br>--gateway=192.168.1.1 \<br>--ipv6 \<br>--subnet=fdfd::/64 \<br>--gateway=fdfd::1 \<br>-o parent=ens18 \<br>test1br0<br></code></pre></td></tr></table></figure><p>其中，</p><ul><li>第一组 <code>--subnet</code> 和 <code>--gateway</code> 是 IPv4 子网段和网关，根据路由器配置进行设置；</li><li>第二组 <code>--subnet</code> 和 <code>--gateway</code> 是为 IPv6 配置的 ULA 网段，根据上面的内容，这部分是私有网段，与宿主机的 IP 设置和路由器设置无关，不会用于公网通信，因此可以自行设置。容器会自动从上级路由获取公网 IPv6 地址。</li><li><code>-o parent</code> 指定了出口网卡，群晖系统一般是 <code>ovs_eth0</code>，需要通过 <code>ifconfig</code> 或 <code>ip a</code> 命令查看实际的出口网卡，还可能是 <code>en0</code>、<code>eth0</code> 等等，务必修改为正确的网卡。</li><li>最后的 <code>test1br0</code> 是网络名，可以自行命名。</li></ul><p>用该命令创建名为 <code>test1br0</code> 的 macvlan 网络，仅后所有用到该网络创建的 docker 容器都会有 ipv6 地址。</p><h2 id="内网服务暴露"><a href="#内网服务暴露" class="headerlink" title="内网服务暴露"></a>内网服务暴露</h2><h3 id="ipv6-流量转发"><a href="#ipv6-流量转发" class="headerlink" title="ipv6 流量转发"></a>ipv6 流量转发</h3><p>因为 ipv6 完全暴露到公网，所以默认情况下路由器会开启 ipv6 防火墙，只允许内部的设备向外访问 ipv6 地址，而不允许外部访问内部。</p><p>所以我们要配置网关的 ipv6 防火墙，对相关流量进行放行。</p><h4 id="Openwrt-防火墙"><a href="#Openwrt-防火墙" class="headerlink" title="Openwrt 防火墙"></a>Openwrt 防火墙</h4><p>进入 网络 - 防火墙 模块，我们可以设置 Openwrt 的防火墙。关于防火墙的详细配置可以参看<a href="https://zt0729.xyz/archives/56/">这篇</a>文章。</p><img src="/images/ipv6 环境下的家庭网络维护/Openwrt 防火墙 常规设置.png" width="70%" /><p>三个出入转发规则：当接口没有加入任何一个防火墙区域的时候，就遵循这个默认规则。</p><p>这里的出入转发都是<strong>针对路由器</strong>而言：</p><ul><li>入站：数据包发送给路由器</li><li>出站：数据包从路由器发出</li><li>转发：流量终点站不是路由器，只是经路由器中转转发</li></ul><h4 id="配置防火墙放行-ipv6-流量"><a href="#配置防火墙放行-ipv6-流量" class="headerlink" title="配置防火墙放行 ipv6 流量"></a>配置防火墙放行 ipv6 流量</h4><p>当前有两种针对 ipv6 流量的放行方式：</p><ul><li>针对 ip 放行</li><li>针对端口放行</li></ul><h5 id="额外配置放行规则"><a href="#额外配置放行规则" class="headerlink" title="额外配置放行规则"></a>额外配置放行规则</h5><p>通过 网络 - 防火墙 - 通信规则，我们可以自定义相关的流量规则。</p><h5 id="匹配固定-ipv6-后缀"><a href="#匹配固定-ipv6-后缀" class="headerlink" title="匹配固定 ipv6 后缀"></a>匹配固定 ipv6 后缀</h5><p>写法：<br><code>::【需要暴露的主机的后缀】/::ffff:ffff:ffff:ffff</code></p><p>一般用于 dhcpv6 这种<strong>后缀固定且有规律</strong>的情况。<br>如你的主机 ipv6 后缀为 <code>d09</code>，则目标地址应填写 <code>::d09/::ffff:ffff:ffff:ffff</code>。</p><h3 id="transmission"><a href="#transmission" class="headerlink" title="transmission"></a>transmission</h3><p>公网 ipv6 对用于 bt&#x2F;pt 的 transmission 十分重要。我们可以通过开放相应端口的形式使之更好地利用 ipv6。</p><h4 id="路由器防火墙配置"><a href="#路由器防火墙配置" class="headerlink" title="路由器防火墙配置"></a>路由器防火墙配置</h4><p>我这里的 transmission 端口为 <code>51413</code>，所以开放所有针对 <code>51413</code> 端口的流量<strong>转发</strong>。<del>这或许太过简单粗暴，也许会有安全隐患，但是胜在方便。</del></p><img src="/images/ipv6 环境下的家庭网络维护/防火墙放行转发流量.png" /><h3 id="使用-Shadowsocks-访问内网"><a href="#使用-Shadowsocks-访问内网" class="headerlink" title="使用 Shadowsocks 访问内网"></a>使用 Shadowsocks 访问内网</h3><p>因为我的 Shadowsocks 容器有独立的 ipv6 地址，所以无法通过常规的 ddns 手段更新 ipv6 地址。如果是 host 模式会简单很多。</p><h4 id="ddns"><a href="#ddns" class="headerlink" title="ddns"></a>ddns</h4><p>这里使用 Openwrt 自带的 ddns-go 来更新路由器 ipv6 地址。</p><p>选择你的 dns 服务商，填好相关信息。</p><img src="/images/ipv6 环境下的家庭网络维护/配置 dns 服务商.png" width="70%" /><p>这里之开启 ipv6 的 ddns 服务。如下选择好，等待更新。</p><img src="/images/ipv6 环境下的家庭网络维护/开启 ipv6 的 ddns.png" width="70%" /><h4 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h4><p>选择 网络 - 端口转发，添加一条端口转发规则。<br>将入站的端口为 <code>9000</code> 的 ipv6 流量转发给本地 Shadowsocks 对应的 ip 和端口。</p><img src="/images/ipv6 环境下的家庭网络维护/对特定端口流量转发.png" /><h4 id="路由器防火墙配置-1"><a href="#路由器防火墙配置-1" class="headerlink" title="路由器防火墙配置"></a>路由器防火墙配置</h4><p><del>不知道为什么前面端口转发勾选的打开防火墙端口没有生效，</del>所以这里在防火墙再开启一下相应端口的流量<strong>入站</strong>。</p><img src="/images/ipv6 环境下的家庭网络维护/防火墙放行入站流量.png" /><h4 id="针对局域网内访问的优化"><a href="#针对局域网内访问的优化" class="headerlink" title="针对局域网内访问的优化"></a>针对局域网内访问的优化</h4><h5 id="ADGuard-home-配置-DNS-重写"><a href="#ADGuard-home-配置-DNS-重写" class="headerlink" title="ADGuard home 配置 DNS 重写"></a>ADGuard home 配置 DNS 重写</h5><p>因为关闭了 ipv6 的 dns 解析，我们这里设置 DNS 重写。<br>在 过滤器 - DNS 重写 页面，可以很方便的添加一条规则，将所有访问对 Shadowsocks 节点域名的请求转发给内网的 Shadowsocks 服务。<del>我使用泛域名统一转发给了 Nginx Proxy Mananger</del></p><h5 id="Nginx-Proxy-Mananger-转发流量"><a href="#Nginx-Proxy-Mananger-转发流量" class="headerlink" title="Nginx Proxy Mananger 转发流量"></a>Nginx Proxy Mananger 转发流量</h5><p>因为我用泛域名将所有请求转发给了 Nginx Proxy Mananger，所以这里在 Nginx Proxy Mananger 多添加一条 Stream 的转发。<br>因为我 Shadowsocks 服务的端口为 <code>9000</code>，所以我将 <code>9000</code> 端口的请求再转发到内网的 Shadowsocks 服务。</p><img src="/images/ipv6 环境下的家庭网络维护/npm stream 模块转发流量.png" /><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>ipv6 还是前景可期的。虽然现在国内相关的建设还不完善，但当下也足够个人使用了。还是希望随着时间的推移，ipv6 推广也能顺利进展下去吧。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.xm.mk/posts/73f9/">使用 macvlan 为 Docker 配置 IPv6</a><br><a href="https://www.right.com.cn/forum/forum.php?mod=viewthread&tid=8217538">【原创】 通过openwrt的IPV6中继(也叫ipv6透传)，使后端设备获得原生ipv6公网地址</a><br><a href="https://www.bilibili.com/read/cv22986275/">unraid系统下macvlan网络的docker容器使用ipv6</a><br><a href="https://blog.men.ci/ipv6-slaac-relay-and-bridge/">SLAAC 环境下的 IPv6 桥接与中继</a><br><a href="https://aws.amazon.com/cn/what-is/cidr/">什么是CIDR？ - CIDR 块和表示法简介 - Amazon AWS</a><br><a href="https://www.v2ex.com/t/875719">关于家庭 ipv6 网络的“裸奔”问题之我见</a><br><a href="https://zt0729.xyz/archives/56/">openwrt 防火墙解析</a><br><a href="https://post.smzdm.com/p/am89gmxp/">超详细，多图，简单，OpenWRT IPV6 端口转发 SOCAT (个人记录)</a><br><a href="https://www.right.com.cn/forum/thread-165814-1-1.html">求助:ipv6端口转发</a><br><a href="https://zhuanlan.zhihu.com/p/79405231">IPv6 — 动态地址配置</a></p>]]></content>
    
    
    <categories>
      
      <category>selfhosted</category>
      
    </categories>
    
    
    <tags>
      
      <tag>transmission</tag>
      
      <tag>docker</tag>
      
      <tag>Shadowsocks</tag>
      
      <tag>Openwrt</tag>
      
      <tag>ipv6</tag>
      
      <tag>ddns</tag>
      
      <tag>防火墙</tag>
      
      <tag>端口转发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 docker 搭建 vaultwarden 密码管理服务</title>
    <link href="/posts/b3a0bacb/"/>
    <url>/posts/b3a0bacb/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天介绍一款密码管理软件 bitwarden。bitwarden 是一款优秀的自由开源密码管理软件，其覆盖多平台且支持自行部署。但由于官方版本过重，使用 rust 重写的第三方开源版 vaultwarden 更适合我们搭建使用——它运行更轻量，也能使用许多官方版本需要付费的功能。</p><h2 id="服务端搭建流程"><a href="#服务端搭建流程" class="headerlink" title="服务端搭建流程"></a>服务端搭建流程</h2><h3 id="使用-docker-搭建-vaultwarden"><a href="#使用-docker-搭建-vaultwarden" class="headerlink" title="使用 docker 搭建 vaultwarden"></a>使用 docker 搭建 vaultwarden</h3><p>使用以下命令搭建，注意替换掉 <code>【你的ADMIN_TOKEN】</code> 和 <code>【数据目录】</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name vaultwarden --restart unless-stopped --hostname vaultwarden -e ADMIN_TOKEN=【你的ADMIN_TOKEN】 -e WEBSOCKET_ENABLED=true -v 【数据目录】:/data/ -p 80:80 -p 3012:3012 vaultwarden/server:latest<br></code></pre></td></tr></table></figure><p>详细设置参数可以在官方文档找到，参见<a href="https://github.com/dani-garcia/vaultwarden/wiki">这里</a>。</p><h3 id="设置-smtp-邮件通知"><a href="#设置-smtp-邮件通知" class="headerlink" title="设置 smtp 邮件通知"></a>设置 smtp 邮件通知</h3><p>进入 <code>http://【容器ip】/admin</code>（如容器ip为 <code>192.168.10.5</code>，则为 <code>http://192.168.10.5/admin</code>），输入之前配置的 <code>【你的ADMIN_TOKEN】</code> 进入管理页面</p><p>点开 SMTP Email Settings 模块，勾选 Enabled 打开，其余部分填入对应内容即可。此处以 QQ 邮箱为例。<br><img src="/images/使用 docker 搭建 vaultwarden 密码管理服务/vaultwarden smtp设置.png" /></p><p>如上，<code>From Address</code> 和 <code>Username</code> 填入邮箱地址，<code>Password</code> 为邮箱密码（或其他凭证，如 QQ 邮箱使用授权码），<code>From Name</code> 为发信人名称。</p><h3 id="设置即时自动同步"><a href="#设置即时自动同步" class="headerlink" title="设置即时自动同步"></a>设置即时自动同步</h3><p>vaultwarden 默认可以定期自动同步，但间隔期可能导致多设备数据不一致，有时甚至会导致未同步信息被覆盖。好在如今，我们可以通过开启 WebSocket 来实现<strong>实时同步</strong>。</p><p>创建容器时的 <code>WEBSOCKET_ENABLED=true</code> 参数来开启 Websocket；如果使用反向代理，则要在反向代理里同步开启。</p><h3 id="对服务进行反向代理"><a href="#对服务进行反向代理" class="headerlink" title="对服务进行反向代理"></a>对服务进行反向代理</h3><p>因web页面<strong>强制要求</strong>使用 https 访问，建议使用反代套一层 https，此处使用 nginx proxy manager。</p><p>填写好 ip 和端口，打开 Websockets Support 和 Block Common Exploits，SSL 选择证书，打开 Force SSL，配置完成。<br><img src="/images/使用 docker 搭建 vaultwarden 密码管理服务/vaultwarden 反代设置.png" width="70%" /></p><h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>点击 Create Account 创建账号，此时的密码为账号的<strong>主密码</strong>。进入 Settings - Options，更改 Language 为中文即可。<br><img src="/images/使用 docker 搭建 vaultwarden 密码管理服务/vaultwarden 设置中文语言.png" /></p><p><strong>注意！主密码非常重要！！</strong><br>Bitwarden 通过帐号和主密码经算法得到一个值，然后用这个值去加密用户的各个密码，最后储存在服务器上。而加密解密都需要在本地进行，也就是说，黑客即使攻破了服务器，仍无法破解密码数据库。这对我们的密码足够安全，但也意味着你一旦忘记主密码，你所有保存的密码将永远无法访问，所以——<strong>请谨慎保管主密码</strong>！</p><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><h3 id="密码生成器"><a href="#密码生成器" class="headerlink" title="密码生成器"></a>密码生成器</h3><p>不论是网页版还是客户端，我们都能很容易找到密码生成器，它可以帮我们生成满足要求的随机密码，这对于账号的安全性有很大的提升。<br><img src="/images/使用 docker 搭建 vaultwarden 密码管理服务/bitwarden插件 密码生成器.png" width="50%" /></p><p><del>试试你的密码要多久才能被破解？——<a href="https://www.security.org/how-secure-is-my-password/">How Secure Is My Password</a></del></p><h3 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h3><p>bitwarden 匹配模式十分重要，它决定了你的账号密码<strong>何时自动填充</strong>到网页中，默认是 基础域 模式，可以根据自己需求适当调整。各个匹配模式<a href="https://help.ppgg.in/auto-fill/using-uris#match-detection-options">摘录</a>如下：</p><h4 id="基础域"><a href="#基础域" class="headerlink" title="基础域"></a>基础域</h4><p>选择基础域，当登录项目的 URI 值的顶级域名和第二级名与检测到的资源相匹配时，Bitwarden 将弹出提示以提供自动填充。<br>例如，URI 的值为 <code>https://google.com</code>，使用基础域匹配检测：</p><table><thead><tr><th>URL</th><th>自动填充？</th></tr></thead><tbody><tr><td><a href="http://google.com/">http://google.com</a></td><td>✔︎</td></tr><tr><td><a href="https://accounts.google.com/">https://accounts.google.com</a></td><td>✔︎</td></tr><tr><td><a href="https://google.net/">https://google.net</a></td><td>✘</td></tr><tr><td><a href="http://yahoo.com/">http://yahoo.com</a></td><td>✘</td></tr></tbody></table><h4 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h4><p>选择主机，当登录项目的 URI 值的主机名和端口（若指定了）与检测到的资源相匹配时，Bitwarden 将弹出提示以提供自动填充。<br>例如，URI 的值为<code>https://sub.domain.com:4000</code>，使用主机匹配检测：</p><table><thead><tr><th>URL</th><th>自动填充？</th></tr></thead><tbody><tr><td><a href="http://sub.domain.com:4000/">http://sub.domain.com:4000</a></td><td>✔︎</td></tr><tr><td><a href="https://sub.domain.com:4000/page.html">https://sub.domain.com:4000/page.html</a></td><td>✔︎</td></tr><tr><td><a href="https://domain.com/">https://domain.com</a></td><td>✘</td></tr><tr><td><a href="https://sub.domain.com/">https://sub.domain.com</a></td><td>✘</td></tr><tr><td><a href="https://sub2.sub.domain.com:4000/">https://sub2.sub.domain.com:4000</a></td><td>✘</td></tr><tr><td><a href="https://sub.domain.com:5000/">https://sub.domain.com:5000</a></td><td>✘</td></tr></tbody></table><h4 id="开始于"><a href="#开始于" class="headerlink" title="开始于"></a>开始于</h4><p>选择开始于，当检测到的资源以登录项目的 URI 值开头（无论后面跟什么）时，Bitwarden 将弹出提示以提供自动填充。<br>例如，URI 的值为<code>https://sub.domain.com/path/</code>，使用开始于匹配检测：</p><table><thead><tr><th>URL</th><th>自动填充？</th></tr></thead><tbody><tr><td><a href="https://sub.domain.com/path/">https://sub.domain.com/path/</a></td><td>✔︎</td></tr><tr><td><a href="https://sub.domain.com/path/page.html">https://sub.domain.com/path/page.html</a></td><td>✔︎</td></tr><tr><td><a href="https://sub.domain.com/">https://sub.domain.com</a></td><td>✘</td></tr><tr><td><a href="https://sub.domain.com:4000/path/page.html%EF%BC%88%E8%A2%AB%E7%AB%AF%E5%8F%A3%E9%98%BB%E6%96%AD%E4%BA%86%EF%BC%89">https://sub.domain.com:4000/path/page.html（被端口阻断了）</a></td><td>✘</td></tr><tr><td><a href="https://sub.domain.com/path%EF%BC%88%E7%BC%BA%E5%B0%91%E6%96%9C%E6%9D%A0%EF%BC%89">https://sub.domain.com/path（缺少斜杠）</a></td><td>✘</td></tr></tbody></table><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>选择正则表达式，当检测到的资源与一个指定的正则表达式相匹配时，Bitwarden 将弹出提示以提供自动填充。正则表达式始终不区分大小写。</p><h5 id="不安全示例"><a href="#不安全示例" class="headerlink" title="不安全示例"></a>不安全示例</h5><p>URI 的值为<code>^https://.*google\.com$</code>，使用正则表达式匹配检测：</p><table><thead><tr><th>URL</th><th>自动填充？</th></tr></thead><tbody><tr><td><a href="https://google.com/">https://google.com</a></td><td>✔︎</td></tr><tr><td><a href="https://sub.google.com/">https://sub.google.com</a></td><td>✔︎</td></tr><tr><td><a href="https://malicious-site.com/?q=google.com">https://malicious-site.com?q=google.com</a></td><td>✔︎</td></tr><tr><td><a href="http://google.com/">http://google.com</a></td><td>✘</td></tr><tr><td><a href="https://yahoo.com/">https://yahoo.com</a></td><td>✘</td></tr></tbody></table><p>这可能比预期的要匹配得更多。</p><h5 id="安全示例"><a href="#安全示例" class="headerlink" title="安全示例"></a>安全示例</h5><p>URI 的值为<code>^https://[a-z]+\.wikipedia\.org/w/index\.php</code>，使用正则表达式匹配检测：</p><table><thead><tr><th>URL</th><th>自动填充？</th></tr></thead><tbody><tr><td><a href="https://en.wikipedia.org/w/index.php?title=Special:UserLogin&amp;returnto=Bitwarden">https://en.wikipedia.org/w/index.php?title=Special:UserLogin&amp;returnto=Bitwarden</a></td><td>✔︎</td></tr><tr><td><a href="https://pl.wikipedia.org/w/index.php?title=Specjalna:Zaloguj&amp;returnto=Bitwarden">https://pl.wikipedia.org/w/index.php?title=Specjalna:Zaloguj&amp;returnto=Bitwarden</a></td><td>✔︎</td></tr><tr><td><a href="https://en.wikipedia.org/w/index.php">https://en.wikipedia.org/w/index.php</a></td><td>✔︎</td></tr><tr><td><a href="https://malicious-site.com/">https://malicious-site.com</a></td><td>✘</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Bitwarden">https://en.wikipedia.org/wiki/Bitwarden</a></td><td>✘</td></tr></tbody></table><h4 id="精确"><a href="#精确" class="headerlink" title="精确"></a>精确</h4><p>选择精确，当登录项目的 URI 值与检测到的资源精确匹配时，Bitwarden 将弹出提示以提供自动填充。<br>例如，URI 的值为<code>https://www.google.com/page.html</code>，使用精确匹配检测：</p><table><thead><tr><th>URL</th><th>自动填充？</th></tr></thead><tbody><tr><td><a href="https://www.google.com/page.html">https://www.google.com/page.html</a></td><td>✔︎</td></tr><tr><td><a href="http://www.google.com/page.html">http://www.google.com/page.html</a></td><td>✘</td></tr><tr><td><a href="https://www.google.com/page.html?query=123">https://www.google.com/page.html?query=123</a></td><td>✘</td></tr><tr><td><a href="https://www.google.com/">https://www.google.com</a></td><td>✘</td></tr></tbody></table><h4 id="从不"><a href="#从不" class="headerlink" title="从不"></a>从不</h4><p>选择从不，Bitwarden 将<strong>从不</strong>为登录项目弹出以提供自动填充。</p><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>接下来就是要自己的所有设备都能连接到密码库，并时刻更新密码了。此处以 chrome 扩展为例，其他客户端都大同小异，也就不多言了。</p><h3 id="chrome-扩展设置"><a href="#chrome-扩展设置" class="headerlink" title="chrome 扩展设置"></a>chrome 扩展设置</h3><p>在 chrome 应用商店搜索找到 bitwarden，添加并启用。点击左上角 设置 ，在 自托管环境 - 服务器URL 处填写自己的反代 url，回到主页就能登录了。<br><img src="/images/使用 docker 搭建 vaultwarden 密码管理服务/bitwarden插件 登录.png" width="50%" /></p><p>点开 设置 页，将 安全 - 密码库超时时间 设置为<strong>从不</strong>，这样比较方便不需要频繁输入密码解锁。<br><img src="/images/使用 docker 搭建 vaultwarden 密码管理服务/bitwarden插件 设置超时时间.png" width="50%" /></p><p>在 设置 页，找到 其他 - 选项 ，点击进入；找到 AUTOFILL，勾选自动填充。<br><img src="/images/使用 docker 搭建 vaultwarden 密码管理服务/bitwarden插件 自动填充.png" width="50%" /></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>到这里，本篇教程就已基本结束了。Bitwarden 是一款很强大的密码管理平台，本文也只简单介绍了部分基础内容。至于剩下更多功能，就留给各位自己<a href="https://help.ppgg.in/">发掘</a>了~</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://ttys3.dev/post/deploy-rust-based-bitwarden-container/">部署基于 Rust 的第三方 Bitwarden 服务端容器</a><br><a href="https://blog.laoda.de/archives/bitwarden-docker-install">【保姆级教程】利用宝塔面板+Docker搭建一个优秀的密码管理器——Bitwarden</a><br><a href="https://www.wenhui.space/docs/01-software-install/install_bitwarden/">Bitwarden的安装 – Wenhui’s Rotten Pen</a><br><a href="https://help.ppgg.in/auto-fill/using-uris#match-detection-options">URI 的使用 - Bitwarden 帮助中心中文版</a><br><a href="https://github.com/dani-garcia/vaultwarden/wiki">Home · dani-garcia_vaultwarden Wiki</a><br><a href="https://help.ppgg.in/">Bitwarden 帮助中心中文版</a></p>]]></content>
    
    
    <categories>
      
      <category>selfhosted</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>密码管理</tag>
      
      <tag>vaultwarden</tag>
      
      <tag>bitwarden</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>陕西广电光猫获取超管密码</title>
    <link href="/posts/96c33dc6/"/>
    <url>/posts/96c33dc6/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>主流的三大运营商（电信、联通、移动）获取光猫超管权限的资料在网上有很多，但如广电之流的破解方法却寥寥无几。如今终于找到了获取广电光猫超管密码的方法，在此分享给大家。</p><p>本次测试的机型为 <em>HGU B1型家庭网关 型号: GL3100B1 固件版本:    V3.0.16353 硬件版本: V20</em>。</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><ol><li><p>使用普通账号密码登录陕西广电光猫后台（此处为 <code>http://192.168.1.1/</code>）。</p><img src="/images/陕西广电光猫获取超管密码/普通用户登录光猫后台.png" width="70%" /></li><li><p>访问 <code>http://192.168.1.1/romfile.cfg</code> 并下载 <code>romfile.cfg</code> 文件。</p></li><li><p>将 <code>romfile.cfg</code> 文件用 VS Code 打开（记事本也行）并查找 <code>useradmin</code>，<code>web_passwd</code> 值即为超级管理员密码（此处即为 <code>5802</code>，密码每个人都不一样，请自行获取）。</p><img src="/images/陕西广电光猫获取超管密码/获取陕西广电光猫的超管密码.png" /></li></ol><p>输入超管账号 <code>useradmin</code> 和密码 <code>5802</code>，可见已经登录到维护后台，接下来就愉快地折腾吧~<br><img src="/images/陕西广电光猫获取超管密码/通过超管账号登录光猫后台.png" /></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/suswulongyuan/article/details/107201857">如何破解光猫，获取超级管理员账户和密码</a></p>]]></content>
    
    
    <categories>
      
      <category>家庭网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>光猫</tag>
      
      <tag>陕西广电</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 docker 搭建 webdav 应用</title>
    <link href="/posts/cb46f731/"/>
    <url>/posts/cb46f731/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直想搭建好 nas 的 webdav 服务，但网上大多数服务都不支持多用户，许多人推荐的 <code>hacdias/webdav</code> 项目也找不到详细的安装教程，也就一直搁置了。如今终于搭建成功，便把个人的搭建流程发出来，希望能帮到有需要的人。<del>因为我也不大懂也就是刚跑起来，所以有问题的地方请大佬们轻喷 orz</del></p><h3 id="更新历史"><a href="#更新历史" class="headerlink" title="更新历史"></a>更新历史</h3><p>20250707 鉴于 <code>hacdias/webdav</code> 项目更新，完善修正了部分内容。</p><h2 id="搭建教程"><a href="#搭建教程" class="headerlink" title="搭建教程"></a>搭建教程</h2><p>咱使用的是 hacdias 大佬的基于 Go 语言的 webdav，项目地址在<a href="https://github.com/hacdias/webdav">这里</a>。这里使用官方的 docker 镜像。</p><h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><p>在准备好的目录（本例为 <code>/docker/webdav</code>）创建配置文件 <code>config.yaml</code>，填入以下内容。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 监听任意网卡，多网卡可指定对应ip</span><br><span class="hljs-attr">address:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br><span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br><br><span class="hljs-comment"># TLS-related settings if you want to enable TLS directly.</span><br><span class="hljs-attr">tls:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">cert:</span> <span class="hljs-string">cert.pem</span><br><span class="hljs-attr">key:</span> <span class="hljs-string">key.pem</span><br><br><span class="hljs-comment"># Prefix to apply to the WebDAV path-ing. Default is &#x27;/&#x27;.</span><br><span class="hljs-attr">prefix:</span> <span class="hljs-string">/</span><br><br><span class="hljs-comment"># Enable or disable debug logging. Default is &#x27;false&#x27;.</span><br><span class="hljs-attr">debug:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Disable sniffing the files to detect their content type. Default is &#x27;false&#x27;.</span><br><span class="hljs-attr">noSniff:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Whether the server runs behind a trusted proxy or not. When this is true,</span><br><span class="hljs-comment"># the header X-Forwarded-For will be used for logging the remote addresses</span><br><span class="hljs-comment"># of logging attempts (if available).</span><br><span class="hljs-attr">behindProxy:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># The directory that will be able to be accessed by the users when connecting.</span><br><span class="hljs-comment"># This directory will be used by users unless they have their own &#x27;directory&#x27; defined.</span><br><span class="hljs-comment"># Default is &#x27;.&#x27; (current directory).</span><br><span class="hljs-attr">directory:</span> <span class="hljs-string">/data</span><br><br><span class="hljs-comment"># The default permissions for users. This is a case insensitive option. Possible</span><br><span class="hljs-comment"># permissions: C (Create), R (Read), U (Update), D (Delete). You can combine multiple</span><br><span class="hljs-comment"># permissions. For example, to allow to read and create, set &quot;RC&quot;. Default is &quot;R&quot;.</span><br><span class="hljs-attr">permissions:</span> <span class="hljs-string">R</span><br><br><span class="hljs-comment"># The default permissions rules for users. Default is none. Rules are applied</span><br><span class="hljs-comment"># from last to first, that is, the first rule that matches the request, starting</span><br><span class="hljs-comment"># from the end, will be applied to the request. Rule paths are always relative to</span><br><span class="hljs-comment"># the user&#x27;s directory.</span><br><span class="hljs-attr">rules:</span> []<br><br><span class="hljs-comment"># The behavior of redefining the rules for users. It can be:</span><br><span class="hljs-comment"># - overwrite: when a user has rules defined, these will overwrite any global</span><br><span class="hljs-comment">#   rules already defined. That is, the global rules are not applicable to the</span><br><span class="hljs-comment">#   user.</span><br><span class="hljs-comment"># - append: when a user has rules defined, these will be appended to the global</span><br><span class="hljs-comment">#   rules already defined. That is, for this user, their own specific rules will</span><br><span class="hljs-comment">#   be checked first, and then the global rules.</span><br><span class="hljs-comment"># Default is &#x27;overwrite&#x27;.</span><br><span class="hljs-attr">rulesBehavior:</span> <span class="hljs-string">overwrite</span><br><br><span class="hljs-comment"># Logging configuration</span><br><span class="hljs-attr">log:</span><br>  <span class="hljs-comment"># Logging format (&#x27;console&#x27;, &#x27;json&#x27;). Default is &#x27;console&#x27;.</span><br>  <span class="hljs-attr">format:</span> <span class="hljs-string">console</span><br>  <span class="hljs-comment"># Enable or disable colors. Default is &#x27;true&#x27;. Only applied if format is &#x27;console&#x27;.</span><br>  <span class="hljs-attr">colors:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># Logging outputs. You can have more than one output. Default is only &#x27;stderr&#x27;.</span><br>  <span class="hljs-attr">outputs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">stderr</span><br><br><span class="hljs-comment"># CORS configuration</span><br><span class="hljs-attr">cors:</span><br>  <span class="hljs-comment"># Whether or not CORS configuration should be applied. Default is &#x27;false&#x27;.</span><br>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">credentials:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">allowed_headers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Depth</span><br>  <span class="hljs-attr">allowed_hosts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">http://localhost:8080</span><br>  <span class="hljs-attr">allowed_methods:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">GET</span><br>  <span class="hljs-attr">exposed_headers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Content-Length</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Content-Range</span><br><br><span class="hljs-comment"># The list of users. If the list is empty, then there will be no authentication.</span><br><span class="hljs-comment"># Otherwise, basic authentication will automatically be configured.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If you&#x27;re delegating the authentication to a different service, you can proxy</span><br><span class="hljs-comment"># the username using basic authentication, and then disable webdav&#x27;s password</span><br><span class="hljs-comment"># check using the option:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># noPassword: true</span><br><span class="hljs-attr">users:</span><br>  <span class="hljs-comment"># Example &#x27;admin&#x27; user with plaintext password.</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">admin</span><br>  <span class="hljs-comment"># Example &#x27;john&#x27; user with bcrypt encrypted password, with custom directory.</span><br>  <span class="hljs-comment"># You can generate a bcrypt-encrypted password by using the &#x27;webdav bcrypt&#x27;</span><br>  <span class="hljs-comment"># command lint utility.</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">username:</span> <span class="hljs-string">john</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">&quot;&#123;bcrypt&#125;$2y$10$zEP6oofmXFeHaeMfBNLnP.DO8m.H.Mwhd24/TOX2MWLxAExXi4qgi&quot;</span><br>    <span class="hljs-attr">directory:</span> <span class="hljs-string">/another/path</span><br>  <span class="hljs-comment"># Example user whose details will be picked up from the environment.</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">username:</span> <span class="hljs-string">&quot;&#123;env&#125;ENV_USERNAME&quot;</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">&quot;&#123;env&#125;ENV_PASSWORD&quot;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">username:</span> <span class="hljs-string">basic</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">basic</span><br>    <span class="hljs-comment"># Override default permissions.</span><br>    <span class="hljs-attr">permissions:</span> <span class="hljs-string">CRUD</span><br>    <span class="hljs-attr">rules:</span><br>      <span class="hljs-comment"># With this rule, the user CANNOT access &#123;user directory&#125;/some/files.</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/some/file</span><br>        <span class="hljs-attr">permissions:</span> <span class="hljs-string">none</span><br>      <span class="hljs-comment"># With this rule, the user CAN create, read, update and delete within</span><br>      <span class="hljs-comment"># &#123;user directory&#125;/public/access.</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/public/access/</span><br>        <span class="hljs-attr">permissions:</span> <span class="hljs-string">CRUD</span><br>      <span class="hljs-comment"># With this rule, the user CAN read and update all files ending with .js.</span><br>      <span class="hljs-comment"># It uses a regular expression.</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">regex:</span> <span class="hljs-string">&quot;^.+.js$&quot;</span><br>        <span class="hljs-attr">permissions:</span> <span class="hljs-string">RU</span><br></code></pre></td></tr></table></figure><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><p>与多数 docker 容器创建相同，值得注意的是要将 <code>config.yaml</code> 所在目录映射进容器，并在启动参数指定 <code>c</code> 为容器内 <code>config.yaml</code>。</p><p>参考：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name webdav-go -v /media:/data/media -v /docker/webdav:/config -p 8081:8081 --restart unless-stopped hacdias/webdav:latest -c /config/config.yaml<br></code></pre></td></tr></table></figure><h4 id="目录与端口映射"><a href="#目录与端口映射" class="headerlink" title="目录与端口映射"></a>目录与端口映射</h4><p>将想要通过 webdav 访问的目录映射进容器内部 <code>/data</code> 目录，配置文件目录 <code>/docker/webdav</code> 映射到容器 <code>/config</code> 目录，端口 <code>8081</code> 映射到外部。</p><h4 id="启动参数"><a href="#启动参数" class="headerlink" title="启动参数"></a>启动参数</h4><p>添加启动参数 <code>-c /config/config.yaml</code>。portainer-ce 安装要在 Advanced container settings - Command &amp; logging 设置，command 设置为 override 并填入参数。<br><img src="/images/使用 docker 搭建 webdav 应用/portainer-ce启动参数.png" width="70%" /></p><h4 id="可访问目录"><a href="#可访问目录" class="headerlink" title="可访问目录"></a>可访问目录</h4><p>我们要将配置文件中 <code>directory</code> 设置为 <code>/data</code>，这样才能直接访问到我们想要共享的目录。默认为 <code>.</code>，此时会直接将项目<strong>根目录</strong>共享出去，这不是我们需要的。</p><h4 id="多用户"><a href="#多用户" class="headerlink" title="多用户"></a>多用户</h4><p>模板中支持对多个用户进行精细的权限控制（详见注释）。我只有一个人用，故只保留必要部分。<br>对配置文件中 <code>users</code> 项进行修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">users:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">username:</span> <span class="hljs-string">your_name</span>       <span class="hljs-comment"># 访问 webdav 的用户名</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">your_password</span>   <span class="hljs-comment"># 访问 webdav 的密码</span><br>    <span class="hljs-attr">directory:</span> <span class="hljs-string">/data</span>        <span class="hljs-comment"># 将 data 目录所有内容共享出来</span><br>    <span class="hljs-attr">permissions:</span> <span class="hljs-string">CRUD</span>       <span class="hljs-comment"># 对目录下文件拥有读写删改所有权限</span><br></code></pre></td></tr></table></figure><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>如果想要使用 SSL 反代来更安全地使用，可以在配置文件将 <code>behindProxy</code> 设置为 <code>true</code>，在日志里就可以清晰看到访问的<strong>真实地址</strong>，否则只会是反代服务器所在的地址。</p><h2 id="挂载-webdav"><a href="#挂载-webdav" class="headerlink" title="挂载 webdav"></a>挂载 webdav</h2><p>推荐使用 RaiDrive 挂载 webdav 盘，2020.6.36 前的版本没有广告。有需求可自行反代。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/hacdias/webdav">hacdias&#x2F;webdav: Simple Go WebDAV server.</a><br><a href="https://www.ztianzeng.com/post/ji-lu-yi-ci-nas-xi-tong-beng-kui/">记录一次NAS系统崩溃</a></p>]]></content>
    
    
    <categories>
      
      <category>selfhosted</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webdav</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 frp 和 Shadowsocks 实现安全访问内网服务</title>
    <link href="/posts/264d1c83/"/>
    <url>/posts/264d1c83/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>初期自建服务器进度完成后，第二步便是实现外网对内网服务的访问（不然岂不是太过鸡肋w)。但苦于没有公网 ip，传统内网穿透（如 frp）把自身服务公开到公网又觉得太不安全，zerotier 虚拟局域网又要频繁切换 vpn 很不方便，总是找不到个万全的方法，因而一直处于搁置状态。如今看到 b 站<code>@靛青K</code>大佬通过 ss 实现内网服务安全访问的方法，咱灵光一闪，想到通过 frp 解决没有公网 ip 问题，进而通过 ss 实现内网安全访问的思路，于是便有了这篇文章——</p><h2 id="主体思路"><a href="#主体思路" class="headerlink" title="主体思路"></a>主体思路</h2><p>通过 clash 实现基于域名的分流，当匹配到特定域名后缀后将流量发往 ss 服务端，ss 服务端通过 frp 实现内网穿透，从而实现安全而又便捷的内网访问功能。相较于传统公网 ip 和 frp 在公网暴露服务的风险隐患，本方法<b>只允许知晓 ss 账号的人通过 ss 访问内网服务</b>，而相对于 zerotier 则<b>连通性更好</b>，还<b>免去了 zerotier 和 clash 不能共存的麻烦</b>，方便很多。</p><h3 id="流量整体转发路径如下"><a href="#流量整体转发路径如下" class="headerlink" title="流量整体转发路径如下"></a>流量整体转发路径如下</h3><p><code>外网访问 =&gt; clash规则匹配分流（ss客户端） =&gt; frps =&gt; frpc =&gt; ss服务端 =&gt; （ADGuard Home 自建DNS） =&gt; 反向代理服务器 =&gt; 目标服务</code></p><h2 id="Shadowsocks-服务端搭建"><a href="#Shadowsocks-服务端搭建" class="headerlink" title="Shadowsocks 服务端搭建"></a>Shadowsocks 服务端搭建</h2><p>本人使用 <code>Shadowsocks-rust</code> 版本，通过 docker 安装。其中【宿主机地址】替换为本地保存 ss 配置文件的目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -p 9000:9000 -p 9000:9000/udp --name shadowsocks-rust --restart=always -v 【宿主机目录】:/etc/shadowsocks-rust teddysun/shadowsocks-rust<br></code></pre></td></tr></table></figure><p>在【宿主机目录】下新建 <code>config.json</code> 文件，内容如下。<code>password0</code> 替换为你的密码，键 <code>dns</code> 的值 <code>192.168.1.1</code> 替换为你的 dns 服务器地址。 <code>method</code> 的值 <code>aes-256-gcm</code> 换为你的加密方式（用咱这个就行，不用动）。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;server&quot;</span>:<span class="hljs-string">&quot;0.0.0.0&quot;</span>,<br><span class="hljs-string">&quot;server_port&quot;</span>:<span class="hljs-number">9000</span>,<br><span class="hljs-string">&quot;password&quot;</span>:<span class="hljs-string">&quot;password0&quot;</span>,<br><span class="hljs-string">&quot;timeout&quot;</span>:<span class="hljs-number">300</span>,<br><span class="hljs-string">&quot;method&quot;</span>:<span class="hljs-string">&quot;aes-256-gcm&quot;</span>,<br><span class="hljs-string">&quot;dns&quot;</span>:<span class="hljs-string">&quot;192.168.1.1&quot;</span>,<br><span class="hljs-string">&quot;mode&quot;</span>:<span class="hljs-string">&quot;tcp_and_udp&quot;</span><br></code></pre></td></tr></table></figure><p>重启 shadowsocks-rust 服务，ss 服务端设置完成。</p><h2 id="使用frp实现内网穿透"><a href="#使用frp实现内网穿透" class="headerlink" title="使用frp实现内网穿透"></a>使用frp实现内网穿透</h2><h3 id="建立frp隧道"><a href="#建立frp隧道" class="headerlink" title="建立frp隧道"></a>建立frp隧道</h3><p>推荐使用 <a href="https://www.natfrp.com/">SAKURA FRP</a> 提供的免费内网穿透服务，普通用户能通过签到每日免费获取流量，内网服务的简单访问足够了（大流量或对网络要求更高的用户请自行购买流量包和 VIP）。</p><p>（申请账号后）登录进入主面版，点击 穿透 - 节点状态 查看所有节点。免费用户节点有限，挑个能用的国内节点就行。<br><img src="/images/使用 frp 和 shadowsocks 实现安全访问内网服务/natfrp节点状态.png" /></p><p>转到 用户 - 用户信息 - 账号信息 处，找到<strong>访问密钥</strong>，记录备用。</p><p>通过 id（上面节点 # 后即为 id）选取节点，转到 穿透 - 隧道列表 - 新建隧道 创建隧道。选择穿透节点，tcp、udp 隧道各创建一个。<br>隧道名随意设置，本地 ip 为 <code>ss服务器ip</code>，本地端口均为 <code>9000</code>（与上面ss的配置文件一致），<b>穿透节点、远程端口均一致</b>，开启压缩和加密。<br><img src="/images/使用 frp 和 shadowsocks 实现安全访问内网服务/tcp隧道建立.png" width="70%" /><br><img src="/images/使用 frp 和 shadowsocks 实现安全访问内网服务/udp隧道建立.png" width="70%" /></p><p>创建完成后，在隧道列表页获取<strong>隧道id</strong>。<br><img src="/images/使用 frp 和 shadowsocks 实现安全访问内网服务/获取隧道id.png" /></p><p>点其中一条隧道最后三个点（<code>操作</code> 项），选择配置文件，找到 <code>[common]</code> 下 <code>server_addr</code> 项，复制 frp 服务器地址备用。</p><h3 id="通过docker安装frpc"><a href="#通过docker安装frpc" class="headerlink" title="通过docker安装frpc"></a>通过docker安装frpc</h3><p>因为使用的是 <a href="https://doc.natfrp.com/#/frpc/usage/docker">SAKURA FRP 提供的服务</a>，所以这里不能使用官方版 frpc，应在 dockerhub 拉取 <code>natfrp/frpc</code> 镜像。</p><p>注意不同于官方 frpc，natfrp 使用用户密钥和隧道 id 拉取配置文件，所以要设置<a href="https://doc.natfrp.com/#/frpc/usage/docker?id=%e5%89%8d%e7%bd%ae%e7%9f%a5%e8%af%86%e8%af%b4%e6%98%8e">启动参数</a>。格式为 <code>&lt;启动密钥&gt;:&lt;隧道ID1&gt;,隧道ID2,隧道ID3,...</code>，其中启动密钥即上一步的访问密钥，隧道 id 即上一步的两个隧道 id。</p><p>使用命令行安装如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name frpc-natfrp --restart=always natfrp/frpc -f &lt;启动参数&gt;<br></code></pre></td></tr></table></figure><p>使用 portainer-ce 安装也可，值得注意的是运行时参数设置在 Advanced container settings - Command &amp; logging 设置，command 设置为 override 并填入参数，如下图。<br><img src="/images/使用 frp 和 shadowsocks 实现安全访问内网服务/portainer-ce创建frpc容器设置.png" /></p><h2 id="clash根据规则分流"><a href="#clash根据规则分流" class="headerlink" title="clash根据规则分流"></a>clash根据规则分流</h2><p>我使用 subconverter 生成包含自定义规则的配置文件，subconverter 可以自己搭建也能用别人搭好的，这里推荐一个 <a href="https://acl4ssr-sub.github.io/">ACL4SSR 在线订阅转换</a>。远程配置使用自己的配置文件模板（可以参考大佬的模板），在 <code>ruleset</code> 和 <code>proxy_group</code> 对应添加节点和规则。配置完成后转换合并订阅即可。</p><h3 id="subconverter-配置文件模板"><a href="#subconverter-配置文件模板" class="headerlink" title="subconverter 配置文件模板"></a>subconverter 配置文件模板</h3><p>subconverter 可以通过设置远程配置实现定制自己需要的规则分流。咱这里使用 GitHub 存储远程配置文件。<del>这里推荐直接复制大佬的模板，然后在此基础上修改。</del><br><img src="/images/使用 frp 和 shadowsocks 实现安全访问内网服务/ACL4SSR_Online配置文件.png" /></p><p>推荐几个基础模板：<br><a href="https://raw.githubusercontent.com/ACL4SSR/ACL4SSR/master/Clash/config/ACL4SSR_Online.ini">ACL4SSR_Online 默认版 分组比较全(与Github同步)</a><br><a href="https://raw.githubusercontent.com/ACL4SSR/ACL4SSR/master/Clash/config/ACL4SSR_Online_Full.ini">ACL4SSR_Online_Full 全分组 重度用户使用(与Github同步)</a></p><p>subconverter 订阅转换设置细则可参考<a href="https://github.com/tindy2013/subconverter/blob/master/README-cn.md">官方使用文档</a>，这里只讲本教程需要的内容。</p><h4 id="Github-创建仓库"><a href="#Github-创建仓库" class="headerlink" title="Github 创建仓库"></a>Github 创建仓库</h4><p>（注册并）登录 Github，创建仓库，创建远程配置文件 <code>config.ini</code>。<del>这里太过简单直接跳过罢</del></p><h4 id="ruleset-设置"><a href="#ruleset-设置" class="headerlink" title="ruleset 设置"></a>ruleset 设置</h4><p>咱这里使用 GitHub 保存规则文件，同仓库下创建 <code>ruleset.list</code>，填入要匹配的的域名或 ip。具体规则在<a href="https://docs.cfw.lbyczf.com/contents/ui/profiles/rules.html">这里</a>。<br>我们这里直接填 <code>DOMAIN-SUFFIX,your-domain.com</code>，将 <code>your-domain.com</code> 替换为你的域名，此行意为以 <code>your-domain.com</code> 为后缀的域名被匹配。最后保存，点击 <code>Raw</code> 获得真实地址。</p><p>复制大佬的配置模板，在配置模板中增加以下一行，<code>=</code> 后面替换为你的 proxy_group 名称 + 规则地址。proxy_group 和 ruleset 名称必须完全一致，否则会报错。注意，规则从上往下匹配，所以最好添加到一列 ruleset 的<strong>最上方</strong>。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ruleset</span>=🏠 家庭内网,https://raw.githubusercontent.com/your_account/your_project/main/rulesets/ruleset.list<br></code></pre></td></tr></table></figure><p>该条的含义是：从 <code>ruleset.list</code> 拉取规则，并将匹配到的流量使用 <code>🏠 家庭内网</code> 中选中的节点转发。</p><h4 id="proxy-group-设置"><a href="#proxy-group-设置" class="headerlink" title="proxy_group 设置"></a>proxy_group 设置</h4><p>在配置模板中增加以下一行，将 <code>GROUPID=1</code> 的 <code>1</code> 换成自己订阅链接或节点的序号（序号<strong>从 0 开始计算</strong>）。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">custom_proxy_group</span>=🏠 家庭内网`select`!!GROUPID=<span class="hljs-number">1</span>`[]DIRECT`http://www.gstatic.com/generate_204`<span class="hljs-number">60</span>,<span class="hljs-number">5</span>,<span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><p>该条的含义是：创建一个名为 <code>🏠 家庭内网</code> 的代理组，使用 <code>select</code> 模式，添加第 2 条订阅和 DIRECT 到该节点组，延迟测速周期 60 秒，5 秒未响应即为超时，延迟容差为 50ms。</p><h4 id="获取远程配置地址"><a href="#获取远程配置地址" class="headerlink" title="获取远程配置地址"></a>获取远程配置地址</h4><p>以上两处修改完成后，GitHub 创建的远程配置文件页点击<code>Raw</code>获取真实地址。</p><h3 id="Shadowsocks-节点链接生成"><a href="#Shadowsocks-节点链接生成" class="headerlink" title="Shadowsocks 节点链接生成"></a>Shadowsocks 节点链接生成</h3><p>一般使用的 ss 链接都经过了 base64 加密，我们这里先生成未加密的节点链接，再加密。</p><h4 id="获得未加密的ss链接"><a href="#获得未加密的ss链接" class="headerlink" title="获得未加密的ss链接"></a>获得未加密的ss链接</h4><p>模板：<code>method:password@hostname:port</code>。</p><p><code>method</code> 是你的 ss 的加密方式，<code>password</code> 是上面设置的密码，<code>hostname</code> 和 <code>port</code> 是上面 frp 服务的地址和<strong>远程端口</strong>，分别替换对应内容。替换后示例 <code>aes-256-gcm:barfoo@hostname:8388</code>。</p><h4 id="通过base64加密获得ss链接"><a href="#通过base64加密获得ss链接" class="headerlink" title="通过base64加密获得ss链接"></a>通过base64加密获得ss链接</h4><p>通过<a href="https://tool.chinaz.com/tools/base64.aspx">这里</a>可以便捷地实现 base64 加密，然后加上 <code>ss://</code> 大功告成，可以额外添加 <code>#节点名称</code> 来给自己的 ss 节点命名。</p><h3 id="通过-subconverter-生成全新订阅"><a href="#通过-subconverter-生成全新订阅" class="headerlink" title="通过 subconverter 生成全新订阅"></a>通过 subconverter 生成全新订阅</h3><p>使用推荐的<a href="https://acl4ssr-sub.github.io/">ACL4SSR 在线订阅转换</a>生成全新订阅。<br>在订阅链接处<strong>按次序</strong>填好机场订阅链接和 ss 链接，在订阅转换的远程配置处粘贴上面得到的远程配置地址，点生成订阅链接即可。</p><img src="/images/使用 frp 和 shadowsocks 实现安全访问内网服务/subconverter生成订阅.png"/><h2 id="DNS-服务器设置"><a href="#DNS-服务器设置" class="headerlink" title="DNS 服务器设置"></a>DNS 服务器设置</h2><p>这里使用 ADGuard Home 做 DNS 服务，ADGuard Home 的 DNS 重写可以看作自定义 hosts 功能。选择 过滤器 - DNS 重写，添加 DNS 重写，ip 为反向代理服务器的 ip。ADGuard Home 这里支持<strong>泛域名</strong>，好评！<br><img src="/images/使用 frp 和 shadowsocks 实现安全访问内网服务/DNS重写.png" /></p><h3 id="内网流量转发设置"><a href="#内网流量转发设置" class="headerlink" title="内网流量转发设置"></a>内网流量转发设置</h3><p>现在，你已经可以实现外网访问本地内网服务了。但内网设备 clash 也会绕这么大一圈来访问内网服务，这不符合我们的初衷。这就需要我们对内网流量转发做额外设置，</p><h3 id="DNS-服务器设置-1"><a href="#DNS-服务器设置-1" class="headerlink" title="DNS 服务器设置"></a>DNS 服务器设置</h3><p>我们在 DNS 重写中，添加域名为 frp 服务器的域名，ip 为反代服务器的 ip。</p><h3 id="反代设置-Streams-流量转发"><a href="#反代设置-Streams-流量转发" class="headerlink" title="反代设置 Streams 流量转发"></a>反代设置 Streams 流量转发</h3><p>这里通过 Nginx Proxy Manager 设置，没有搭建的同学可以查看咱之前的搭建教程：<a href="https://sunjx97.github.io/posts/233f7ebd/"><em>使用 docker 搭建 nginx proxy manager 实现反向代理和 SSL 证书申请</em></a>。</p><p>Nginx 的 Stream 模块工作在第四层，我们可以用来转发 tcp、udp 数据包。登录管理页面，点击 Streams - Add Stream，<code>Incoming Port</code> 填 frp 隧道的<strong>远程端口</strong>，<code>Forward Host</code> 填 ss 服务端的 ip，<code>Forward Port</code> 填 ss 服务端的端口（即上面设置的<code>9000</code>）。</p><p>设置完毕，此时如果我们回到家里，也不用手动切换为 DIRECT，访问内网服务的数据会自动导向反代服务器，进而转发到 ss 服务回到内网，无需担心浪费 frp 的流量。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此，本教程终于结束了。对于内外网两栖的设备在节点组需要选择自己的 ss 节点，而内网设备直接选择 DIRECT 即可，DNS 和反代服务器会将流量转发到正确的服务 ip 和端口。相对于 <code>@靛青K</code> 大佬直接使用 ddns 和公网 ip 搭建 ss 服务端，这个方法肯定麻烦许多，但对于当前 ipv6 未全面铺开的情况和大内网的我来说，终归是够用了。<del>所以 ipv6 时代什么时候来啊 (#&#96;O′)&#x2F;</del></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/read/cv9219407">使用 Shadowsocks 访问家庭内网</a><br><a href="https://doc.natfrp.com/#/frpc/usage/docker">使用 docker 管理 frpc 运行 - SAKURA FRP</a><br><a href="https://github.com/tindy2013/subconverter/blob/master/README-cn.md">subconverter 官方使用文档</a><br><a href="https://docs.cfw.lbyczf.com/contents/ui/profiles/rules.html">规则编辑 - Clash for Windows</a><br><a href="https://blog.kelu.org/tech/2017/04/25/generate-shadowsocks-qrcode.html">shadowsocks 生成二维码 URI</a><br><a href="https://yjdwbj.github.io/2020/02/12/%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%A4%96VPS%E6%8C%87%E5%8D%97-Linode/#URI%E4%B8%8E%E4%BA%8C%E7%BB%B4%E7%A0%81">URI与二维码 - shadowsocks-libev</a></p>]]></content>
    
    
    <categories>
      
      <category>selfhosted</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网穿透</tag>
      
      <tag>frp</tag>
      
      <tag>Shadowsocks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 transmission 使用网络共享的监控目录时的监控失灵问题</title>
    <link href="/posts/7133bd05/"/>
    <url>/posts/7133bd05/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>transmission 可以通过设置 watch 监控文件夹来自动添加监控目录内的种子，但如果监控文件夹是 smb 共享，则会出现失灵的现象（即只在开启或重启时添加一次目录内的种子）。本人使用 NAS 集中管理自己的数据，docker 版 transmission 也是映射的主机挂载的 smb 共享文件夹，便出现了日常使用不自动添加种子的问题。</p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>transmission 在 Linux 下默认使用 inotify 监控监控目录，而 inotify 不对 cifs 共享有效。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在配置文件目录的 <code>settings.json</code> 加入下行即可。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;watch-dir-force-generic&quot;</span>: <span class="hljs-literal">true</span>,<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://forum.transmissionbt.com/viewtopic.php?t=17960">Watch-dir on network folder</a></p>]]></content>
    
    
    <categories>
      
      <category>selfhosted</category>
      
    </categories>
    
    
    <tags>
      
      <tag>transmission</tag>
      
      <tag>pt</tag>
      
      <tag>smb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决通过 fstab 开机挂载 smb 文件夹导致的 Database is locked 问题</title>
    <link href="/posts/cbb0bc9e/"/>
    <url>/posts/cbb0bc9e/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>发现在使用 <code>fstab</code> 开机挂载的 smb 文件夹会有 <code>Database is locked</code> 的问题，如通过 docker 安装的 nginx-proxy-manager 和 qiandao，映射的文件夹是 smb（cifs）共享挂载的，因为默认使用了 sqlite 的数据库，会导致 <code>Database is locked</code> 问题，如下图：</p><img src="/images/解决通过 fstab 开机挂载 smb 文件夹导致的 Database-is-locked 问题/sqlite报错 01.png" width="70%" /><img src="/images/解决通过 fstab 开机挂载 smb 文件夹导致的 Database-is-locked 问题/sqlite报错 02.png" /><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在挂载时加入 <code>nolock</code> 参数即可。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//my</span>server /mymount cifs username=**,password=**,nolock,uid=<span class="hljs-number">1000</span>,gid=<span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.archiware.com/blog/pure_forum/pure-question-answers/database-is-locked/">Database is locked</a></p>]]></content>
    
    
    <categories>
      
      <category>selfhosted</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>smb</tag>
      
      <tag>sqlite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蜗牛星际 A 款机箱的六盘位改造</title>
    <link href="/posts/b040efc9/"/>
    <url>/posts/b040efc9/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>距离改造已经过去很久了，直到现在才发出来_(:3」∠)_</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>因为蜗牛星际A款机箱本来就带一个 2.5 寸硬盘位（机箱内部），所以只要再扩展出一个 2.5 寸硬盘位即可。</p><p>用到了一个 2.5 寸硬盘支架，购买链接在<a href="https://item.taobao.com/item.htm?id=605572434546">这里</a>，购买<strong>半高 PCIe 款</strong>。</p><p>使用的螺丝购买链接在<a href="https://detail.tmall.com/item.htm?id=606010296755">这里</a>，<strong>规格为 M3</strong>，建议买短点。</p><ol><li><p>先用四个螺丝将支架和硬盘固定（硬盘有一面有四个螺丝孔），我这边买的螺丝比较长，所以用螺母当垫片使用。</p><img src="/images/蜗牛星际 A 款机箱的六盘位改造/增加2.5寸盘位 01.jpg" /></li><li><p>因为螺丝本身有厚度，所以支架最底下那个盘位要空出来，直接在第二个盘位安装 2.5 寸硬盘即可。</p><img src="/images/蜗牛星际 A 款机箱的六盘位改造/增加2.5寸盘位 02.jpg" /><img src="/images/蜗牛星际 A 款机箱的六盘位改造/增加2.5寸盘位 03.jpg" /></li></ol><p>成品如图：<br><img src="/images/蜗牛星际 A 款机箱的六盘位改造/增加2.5寸盘位 04.jpg" /><br><img src="/images/蜗牛星际 A 款机箱的六盘位改造/增加2.5寸盘位 05.jpg" /></p><p>大概只能扩充到 2 个 2.5 寸盘位，毕竟离机箱壁太近了。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>机箱内部的 2.5 寸盘位因为要将 4 个螺丝孔那面对外，所以<strong>对硬盘厚度有要求</strong>，建议厚盘装在外面。</p>]]></content>
    
    
    <categories>
      
      <category>DIY</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蜗牛星际</tag>
      
      <tag>DIY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 docker 搭建 nginx proxy manager 实现反向代理和 SSL 证书申请</title>
    <link href="/posts/233f7ebd/"/>
    <url>/posts/233f7ebd/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自从入坑 NAS 以来，（黑）群晖一直都是我文件存储管理的得力助手。但随着我的<del>圈内吹水日益熟练</del>学习和理解不断加深，黑裙已不能满足我的需求。如今，是时候告别（黑）群晖，往更专业的自建服务器方向发展了。其中关键的一步，便是找到能方便替换群晖反向代理服务的开源项目，而 nginx proxy manager 给了我一个很好的选择。</p><h2 id="nginx-proxy-manager-介绍"><a href="#nginx-proxy-manager-介绍" class="headerlink" title="nginx proxy manager 介绍"></a>nginx proxy manager 介绍</h2><p>nginx proxy manager 能让我们轻松地转发到在家里或其他地方运行的网站，包括免费的 SSL，而不需要对 Nginx 或 Letsencrypt 了解太多。便捷直观的 web 页面管理和操作无疑大大简化了一般 nginx 反代服务的步骤。</p><h2 id="docker-安装-nginx-proxy-manager"><a href="#docker-安装-nginx-proxy-manager" class="headerlink" title="docker 安装 nginx proxy manager"></a>docker 安装 nginx proxy manager</h2><p>推荐使用 docker-compose 安装</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">app:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">&#x27;jc21/nginx-proxy-manager:latest&#x27;</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-comment"># These ports are in format &lt;host-port&gt;:&lt;container-port&gt;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;80:80&#x27;</span> <span class="hljs-comment"># Public HTTP Port</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;443:443&#x27;</span> <span class="hljs-comment"># Public HTTPS Port</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;81:81&#x27;</span> <span class="hljs-comment"># Admin Web Port</span><br>      <span class="hljs-comment"># Add any other Stream port you want to expose</span><br>      <span class="hljs-comment"># - &#x27;21:21&#x27; # FTP</span><br><br>    <span class="hljs-comment"># Uncomment the next line if you uncomment anything in the section</span><br>    <span class="hljs-comment"># environment:</span><br>      <span class="hljs-comment"># Uncomment this if you want to change the location of </span><br>      <span class="hljs-comment"># the SQLite DB file within the container</span><br>      <span class="hljs-comment"># DB_SQLITE_FILE: &quot;/data/database.sqlite&quot;</span><br><br>      <span class="hljs-comment"># Uncomment this if IPv6 is not enabled on your host</span><br>      <span class="hljs-comment"># DISABLE_IPV6: &#x27;true&#x27;</span><br><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./data:/data</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./letsencrypt:/etc/letsencrypt</span><br></code></pre></td></tr></table></figure><p>浏览器输入【docker主机ip:81】，成功进入 web 页面，初次登录使用邮箱：<a href="mailto:&#x61;&#x64;&#x6d;&#x69;&#x6e;&#x40;&#x65;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;">&#x61;&#x64;&#x6d;&#x69;&#x6e;&#x40;&#x65;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;</a>，密码：changeme。<br><img src="/images/使用 docker 搭建 nginx-proxy-manager 实现反向代理和 SSL 证书申请/通过docker安装nginx proxy manager 01.png" /></p><p>登录进去后会让你设置管理员的用户名（Full Name），昵称（Nickname）和邮箱。<br><img src="/images/使用 docker 搭建 nginx-proxy-manager 实现反向代理和 SSL 证书申请/通过docker安装nginx proxy manager 02.png" width="60%" /></p><p>接下来设置密码，旧密码即预设密码 changeme。<br><img src="/images/使用 docker 搭建 nginx-proxy-manager 实现反向代理和 SSL 证书申请/通过docker安装nginx proxy manager 03.png" width="60%" /></p><p>至此，nginx proxy manager 初始化完成。</p><h2 id="使用nginx-proxy-manager-实现反向代理"><a href="#使用nginx-proxy-manager-实现反向代理" class="headerlink" title="使用nginx proxy manager 实现反向代理"></a>使用nginx proxy manager 实现反向代理</h2><p>登录进入主面版，点击 Proxy Hosts 转到反向代理设置界面。<br><img src="/images/使用 docker 搭建 nginx-proxy-manager 实现反向代理和 SSL 证书申请/nginx proxy manager反向代理 01.png" /></p><p>点击 Add Proxy Host，添加一个反向代理。<br><img src="/images/使用 docker 搭建 nginx-proxy-manager 实现反向代理和 SSL 证书申请/nginx proxy manager反向代理 02.png" /></p><p>在 Details 页面，Domain Names 填写你的域名，Scheme 填写反代对象的协议（http&#x2F;https），Forward Hostname&#x2F;IP 填写反代对象的地址，Forward Port 填写反代对象的端口号。</p><p><code>Domain Names</code> - 填写需要反代的域名<br><code>Scheme</code> - 选择来源的协议<br><code>Forward Hostname / IP</code> - 填写来源的主机名或IP<br><code>Forward Port</code> - 填写来源的端口<br><code>Cache Assets</code> - 是否启用缓存<br><code>Block Common Expoits</code> - 阻止常见的漏洞<br><code>Websockets Support</code> - 是支援 Websockets<br><code>Access List</code> - 权限列表选择，可以给反代的网页设置账户密码，验证通过后才能正常打开</p><img src="/images/使用 docker 搭建 nginx-proxy-manager 实现反向代理和 SSL 证书申请/nginx proxy manager反向代理 03.png" width="60%" /><p>如果有 https 加密需求，转到 SSL 页面，将 SSL Certificate 选择为你申请的证书，建议勾选 SSL Force（强制SSL）。<br><img src="/images/使用 docker 搭建 nginx-proxy-manager 实现反向代理和 SSL 证书申请/nginx proxy manager反向代理 04.png" width="60%" /></p><p>点击保存，在反向代理页面可以看到刚刚设置的反向代理。<br><img src="/images/使用 docker 搭建 nginx-proxy-manager 实现反向代理和 SSL 证书申请/nginx proxy manager反向代理 05.png" /></p><p>测试相应网站，反代成功。</p><h2 id="SSL-证书申请"><a href="#SSL-证书申请" class="headerlink" title="SSL 证书申请"></a>SSL 证书申请</h2><h3 id="HTTP-01-验证方式"><a href="#HTTP-01-验证方式" class="headerlink" title="HTTP-01 验证方式"></a>HTTP-01 验证方式</h3><p>最简单常规的 SSL 证书申请方式，如果你的主机可以放行 80 端口（如在各大公有云处购买的主机），推荐使用这种方式。<del>我这边没有虚拟主机，家用80端口也被封锁了，所以也没用过这种方式，姑且放在这里给大家参考_(:3」∠)_</del></p><p>转到反代编辑页面，在 SSL 页面选择 Request a new SSL Certificate，建议勾选 SSL Force（强制SSL），打开勾选 I Agree to the Let’s Encrypt Terms of Service 同意 Let’s Encrypt 相关条款，点击保存。<br><img src="/images/使用 docker 搭建 nginx-proxy-manager 实现反向代理和 SSL 证书申请/nginx proxy manager设置SSL证书 HTTP-01.png" width="60%" /></p><p>可以看到反代已自动申请 SSL 证书，可以通过 https 访问了。证书有效期 3 个月，到期会自动续期。</p><h3 id="DNS-01-验证方式"><a href="#DNS-01-验证方式" class="headerlink" title="DNS-01 验证方式"></a>DNS-01 验证方式</h3><p>因为国内 ISP 一般都封锁了 80 端口，所以 HTTP-01 验证方式大概率在家庭自建服务器的情况下不会成功。作为替代，我们可以选择使用 DNS-01 的验证方式来申请 SSL 证书。相较于 HTTP-01，DNS-01 可以申请<a href="https://letsencrypt.org/zh-cn/docs/challenge-types/">支持通配符的域名证书</a>，也算弥补了其操作繁琐的缺点。这里以 DNSPOD 和 CloudFlare 为例：</p><h4 id="DNSPOD"><a href="#DNSPOD" class="headerlink" title="DNSPOD"></a>DNSPOD</h4><h5 id="1-申请-api-key"><a href="#1-申请-api-key" class="headerlink" title="1. 申请 api key"></a>1. 申请 api key</h5><p>首先登录 DNSPOD 控制台，在右上角找到 API 密钥 项。<br><img src="/images/使用 docker 搭建 nginx-proxy-manager 实现反向代理和 SSL 证书申请/DNSPOD API申请 01.png" width="50%" /></p><p>转到 DNSPod Token 页面，点击创建密钥。<br><img src="/images/使用 docker 搭建 nginx-proxy-manager 实现反向代理和 SSL 证书申请/DNSPOD API申请 02.png" width="60%" /></p><p>设置密钥名称<br><img src="/images/使用 docker 搭建 nginx-proxy-manager 实现反向代理和 SSL 证书申请/DNSPOD API申请 03.png" width="60%" /></p><p>查看并保存 ID 和 Token 项，这里的内容<strong>只会显示一次</strong>，一定要保存好。<br><img src="/images/使用 docker 搭建 nginx-proxy-manager 实现反向代理和 SSL 证书申请/DNSPOD API申请 04.png" width="60%" /></p><p>已经能在总览看到相关 API 已申请成功。<br><img src="/images/使用 docker 搭建 nginx-proxy-manager 实现反向代理和 SSL 证书申请/DNSPOD API申请 05.png" /></p><h5 id="2-配置-nginx-proxy-manager-并申请-SSL-证书"><a href="#2-配置-nginx-proxy-manager-并申请-SSL-证书" class="headerlink" title="2. 配置 nginx proxy manager 并申请 SSL 证书"></a>2. 配置 nginx proxy manager 并申请 SSL 证书</h5><p>点击 SSL Certificates，转到 SSL Certificates 页面；再点击右上角 Add SSL Certificate，选择 Let’s Encrypt。<br><img src="/images/使用 docker 搭建 nginx-proxy-manager 实现反向代理和 SSL 证书申请/nginx proxy manager设置SSL证书 DNS-01 01.png" /></p><p>如下图，Domain names 填写自己的域名，Email Address for Let’s Encrypt 填写自己的邮箱。</p><p>打开 Use a DNS Challenge，DNS Provider 选择 DNSPod，将 <code>dns_dnspod_email</code> 中的 <code>email@example.com</code> 替换为 DNSPod 的邮箱，<code>dns_dnspod_api_token</code> 中的 <code>id,key</code> 对应填入（即在上一步申请得到的 id 和 token），注意不要删掉英文双引号，且 id 与 token 用英文逗号连接。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">dns_dnspod_email</span> = <span class="hljs-string">&quot;email@example.com&quot;</span><br><span class="hljs-attr">dns_dnspod_api_token</span> = <span class="hljs-string">&quot;id,key&quot;</span><br></code></pre></td></tr></table></figure><p>勾选 I Agree to the Let’s Encrypt Terms of Service 同意 Let’s Encrypt 相关条款，点击保存。<br><img src="/images/使用 docker 搭建 nginx-proxy-manager 实现反向代理和 SSL 证书申请/nginx proxy manager设置SSL证书 DNS-01 02.png" /></p><p>可以看到 SSL 证书已经申请完成，有效期 3 个月，到期会自动续期。<br><img src="/images/使用 docker 搭建 nginx-proxy-manager 实现反向代理和 SSL 证书申请/nginx proxy manager设置SSL证书 DNS-01 03.png" /></p><h4 id="CloudFlare"><a href="#CloudFlare" class="headerlink" title="CloudFlare"></a>CloudFlare</h4><h5 id="1-获取-api-key"><a href="#1-获取-api-key" class="headerlink" title="1. 获取 api key"></a>1. 获取 api key</h5><p>打开<a href="https://dash.cloudflare.com/profile/api-tokens">个人资料 - API 令牌</a>，找到 <strong>API 密钥</strong>，查看并复制 <strong>Global API Key</strong>。</p><h5 id="2-配置-nginx-proxy-manager-并申请-SSL-证书-1"><a href="#2-配置-nginx-proxy-manager-并申请-SSL-证书-1" class="headerlink" title="2. 配置 nginx proxy manager 并申请 SSL 证书"></a>2. 配置 nginx proxy manager 并申请 SSL 证书</h5><p>同上，不过要将申请信息进行替换（初始的只有 api token 的形式申请会有问题）。<code>something@hotmail.com</code> 替换为 cloudflare 的邮箱，<code>0123456789abcdef0123456789abcdef01234567</code> 替换为上面得到的 Global API Key。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># Cloudflare API token</span><br><span class="hljs-attr">dns_cloudflare_email</span> = something@hotmail.com<br><span class="hljs-attr">dns_cloudflare_api_key</span> = <span class="hljs-number">0123456789</span>abcdef0123456789abcdef01234567<br></code></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="需要开启-Websockets-Support-的应用-x2F-网站"><a href="#需要开启-Websockets-Support-的应用-x2F-网站" class="headerlink" title="需要开启 Websockets Support 的应用&#x2F;网站"></a>需要开启 Websockets Support 的应用&#x2F;网站</h3><p>Proxmox VE：不开启会导致 novnc 连接错误<br>jlesage&#x2F;jdownloader-2：不开启会无法进入 webui 管理页面<br>truenas：不开启会导致 webui 无法登录<br>portainer&#x2F;portainer-ce：不开启无法对容器使用 console</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://nginxproxymanager.com/guide/#project-goal">Nginx Proxy Manager</a><br><a href="https://letsencrypt.org/zh-cn/docs/challenge-types/">验证方式 - Let’s Encrypt</a><br><a href="https://www.bilibili.com/video/BV1Gg411w7kQ">【Docker系列】一个反向代理神器——Nginx Proxy Manager</a><br><a href="https://blog.laoda.de/archives/nginxproxymanager">【Docker系列】一个反向代理神器——Nginx Proxy Manager</a><br><a href="https://www.jianshu.com/p/659dc904967f">certbot dns插件</a><br><a href="https://github.com/NginxProxyManager/nginx-proxy-manager/issues/680#issuecomment-722016183">Cannot get Let’s Encrypt cert via cloudflare dns challange</a><br><a href="https://www.sio.moe/2021/12/18/computer/Docker-Container/Use-Docker-to-install-Nginx-ProxyManager-for-SSL-reverse-proxy/">使用Docker安裝Nginx-ProxyManager進行SSL反向代理</a></p>]]></content>
    
    
    <categories>
      
      <category>selfhosted</category>
      
    </categories>
    
    
    <tags>
      
      <tag>反向代理</tag>
      
      <tag>SSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Transmission 2.94 升级 3.00 跳过启动校验</title>
    <link href="/posts/402aacbe/"/>
    <url>/posts/402aacbe/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>将 transmission 升级到了 3.00，发现每次启动都会对升级前的旧种子重新校验，然后就是数十个小时的校验过程，实在让人头大。经过多次尝试，终于找到可以跳过启动校验（只校验一次）的方法了，现记录如下。</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>transmission 在 3.00 使用 <strong>40 位 hash</strong> 记录种子文件的信息（之前是 16 位），在 torrents 和 resume 文件夹中新生成的文件都是用 40 位 hash 值命名的。要解决每次启动都重复校验的问题，需要将旧种子的信息更新。主要有以下几步：</p><ol><li>等待 transmission 第一次校验完生成<strong>新的 40 位 hash 命名的 resume 文件</strong>并将旧种子的的 resume 文件删除</li><li>将对应的旧种子的 torrent 文件更名为<strong>相同的 40 位 hash</strong>。</li></ol><h3 id="等待初次校验完成"><a href="#等待初次校验完成" class="headerlink" title="等待初次校验完成"></a>等待初次校验完成</h3><img src="/images/Transmission 2.94 升级 3.00 跳过启动校验/resume新旧文件对比.png" width="70%" /><p>等待校验完成并删除旧 resume 文件（很好分辨，2.94 版本是【种子名 + 前 16 位 hash】的命名方式，而 3.0 版本生成的新 resume 文件都是【40 位 hash】命名方式）</p><h3 id="对旧-torrent-文件重命名"><a href="#对旧-torrent-文件重命名" class="headerlink" title="对旧 torrent 文件重命名"></a>对旧 torrent 文件重命名</h3><p>停止 docker 中的 transmission服务，将旧 torrent 文件重命名为新 40 位 hash 形式。<br>因为旧 torrent 文件名称包含前 16 位 hash，所以可以直接将 16 位 hash 字符串与 resume 文件夹内所有文件进行匹配，如果匹配上前 16 位，则修正命名。</p><p>写了段<a href="https://github.com/sunjx97/torrent-file-rename">代码</a>解决命名问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> re<br><br>torrents_src = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入torrents文件夹绝对路径：&#x27;</span>)<br>resume_src = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入resume文件夹绝对路径：&#x27;</span>)<br><br>torrent_list = os.listdir(torrents_src)<br>resume_list = os.listdir(resume_src)<br><br>count = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> torrent <span class="hljs-keyword">in</span> torrent_list:<br>    <span class="hljs-comment"># 从16位hash值开始，到后缀名结束</span><br>    <span class="hljs-comment"># 如果是新版文件40位hash，则会截取后16位，在下面match起始位置匹配匹配失败</span><br>    pattern = torrent[-<span class="hljs-number">24</span>:-<span class="hljs-number">8</span>]<br><br>    <span class="hljs-keyword">for</span> resume <span class="hljs-keyword">in</span> resume_list:<br>        <span class="hljs-keyword">if</span> re.match(pattern, resume[:-<span class="hljs-number">7</span>], re.I):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Ok, find the files!&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;torrent:&#x27;</span>, torrent)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;resume:&#x27;</span>, resume)<br>            os.rename(torrents_src+<span class="hljs-string">&#x27;\\&#x27;</span>+torrent, torrents_src+<span class="hljs-string">&#x27;\\&#x27;</span>+resume[:-<span class="hljs-number">7</span>]+<span class="hljs-string">&#x27;.torrent&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;torrent&#125;</span> 已更名为 <span class="hljs-subst">&#123;resume[:-<span class="hljs-number">7</span>]&#125;</span>.torrent&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;==========================&#x27;</span>)<br>            count += <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;已成功命名<span class="hljs-subst">&#123;count&#125;</span>个种子文件&#x27;</span>)<br></code></pre></td></tr></table></figure><p>运行结果如下，一切顺利。<br><img src="/images/Transmission 2.94 升级 3.00 跳过启动校验/torrent更名成功.png" /></p><p>启动 transmission，可以看到已经没有在校验了。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>在操作前<strong>备份</strong>好 torrents 和 resume 文件夹</li><li>初次校验完成后建议<strong>停止</strong> transmission 服务后再操作。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/ylxb2016/PT-help/blob/master/PT%20Tutorial/%E3%80%90%E5%8E%9F%E5%88%9B%E3%80%91Transmission%20%E6%89%8B%E5%8A%A8%E8%B7%B3%E8%BF%87%E6%A0%A1%E9%AA%8C%20%E6%95%99%E7%A8%8B.md">【原创】Transmission 手动跳过校验 教程.md</a><br><a href="https://forum.transmissionbt.com/viewtopic.php?f=2&t=20838&p=80079&hilit=resume&sid=6a23eb2473eab4b32c5df60332c16ae1">Move a half downloaded file from Android to Windows&#x2F;Linux</a><br><a href="https://forum.transmissionbt.com/viewtopic.php?f=2&t=20694&p=79636&hilit=resume&sid=6a23eb2473eab4b32c5df60332c16ae1#p79636">Reinstall Transmission and moving data to avoid torrent recheck</a></p>]]></content>
    
    
    <categories>
      
      <category>pt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>transmission</tag>
      
      <tag>pt</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
